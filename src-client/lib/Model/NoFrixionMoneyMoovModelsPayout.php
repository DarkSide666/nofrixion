<?php
/**
 * NoFrixionMoneyMoovModelsPayout
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NoFrixion MoneyMoov API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Nofrixion\Client\Model;

use \ArrayAccess;
use \Nofrixion\Client\ObjectSerializer;

/**
 * NoFrixionMoneyMoovModelsPayout Class Doc Comment
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class NoFrixionMoneyMoovModelsPayout implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'NoFrixion.MoneyMoov.Models.Payout';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'string',
        'payrun_id' => 'string',
        'account_id' => 'string',
        'merchant_id' => 'string',
        'user_id' => 'string',
        'approver_id' => 'string',
        'topup_payrun_id' => 'string',
        'type' => 'string',
        'description' => 'string',
        'currency' => 'string',
        'amount' => 'float',
        'formatted_amount' => 'string',
        'your_reference' => 'string',
        'their_reference' => 'string',
        'can_process' => 'bool',
        'batch_payout_id' => 'string',
        'merchant_token_description' => 'string',
        'status' => 'string',
        'current_user_id' => 'string',
        'current_user_role' => 'string',
        'approve_payout_url' => 'string',
        'created_by' => 'string',
        'created_by_email_address' => 'string',
        'inserted' => '\DateTime',
        'source_account_name' => 'string',
        'source_account_iban' => 'string',
        'source_account_number' => 'string',
        'source_account_sortcode' => 'string',
        'source_bitcoin_address' => 'string',
        'source_account_identifier' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsAccountIdentifier',
        'source_account_available_balance' => 'float',
        'formatted_source_account_available_balance' => 'string',
        'destination' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsCounterparty',
        'invoice_id' => 'string',
        'tags' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTag[]',
        'scheduled' => 'bool',
        'schedule_date' => '\DateTime',
        'formatted_schedule_day_only' => 'string',
        'formatted_schedule' => 'string',
        'bitcoin_subtract_fee_from_amount' => 'bool',
        'bitcoin_fee_sats_per_vbyte' => 'int',
        'formatted_bitcoin_fee' => 'string',
        'authorisers_required_count' => 'int',
        'authorisers_completed_count' => 'int',
        'can_authorise' => 'bool',
        'can_update' => 'bool',
        'has_current_user_authorised' => 'bool',
        'authorised_by' => 'string[]',
        'payrun_name' => 'string',
        'beneficiary' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsBeneficiary',
        'payment_processor' => 'string',
        'events' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPayoutEvent[]',
        'rule' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsRuleMinimal',
        'payment_rail' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => 'uuid',
        'payrun_id' => 'uuid',
        'account_id' => 'uuid',
        'merchant_id' => 'uuid',
        'user_id' => 'uuid',
        'approver_id' => 'uuid',
        'topup_payrun_id' => 'uuid',
        'type' => null,
        'description' => null,
        'currency' => null,
        'amount' => 'double',
        'formatted_amount' => null,
        'your_reference' => null,
        'their_reference' => null,
        'can_process' => null,
        'batch_payout_id' => 'uuid',
        'merchant_token_description' => null,
        'status' => null,
        'current_user_id' => 'uuid',
        'current_user_role' => null,
        'approve_payout_url' => null,
        'created_by' => null,
        'created_by_email_address' => null,
        'inserted' => 'date-time',
        'source_account_name' => null,
        'source_account_iban' => null,
        'source_account_number' => null,
        'source_account_sortcode' => null,
        'source_bitcoin_address' => null,
        'source_account_identifier' => null,
        'source_account_available_balance' => 'double',
        'formatted_source_account_available_balance' => null,
        'destination' => null,
        'invoice_id' => null,
        'tags' => null,
        'scheduled' => null,
        'schedule_date' => 'date-time',
        'formatted_schedule_day_only' => null,
        'formatted_schedule' => null,
        'bitcoin_subtract_fee_from_amount' => null,
        'bitcoin_fee_sats_per_vbyte' => 'int32',
        'formatted_bitcoin_fee' => null,
        'authorisers_required_count' => 'int32',
        'authorisers_completed_count' => 'int32',
        'can_authorise' => null,
        'can_update' => null,
        'has_current_user_authorised' => null,
        'authorised_by' => null,
        'payrun_name' => null,
        'beneficiary' => null,
        'payment_processor' => null,
        'events' => null,
        'rule' => null,
        'payment_rail' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
        'payrun_id' => true,
        'account_id' => false,
        'merchant_id' => false,
        'user_id' => true,
        'approver_id' => true,
        'topup_payrun_id' => true,
        'type' => false,
        'description' => true,
        'currency' => false,
        'amount' => false,
        'formatted_amount' => true,
        'your_reference' => true,
        'their_reference' => true,
        'can_process' => false,
        'batch_payout_id' => true,
        'merchant_token_description' => true,
        'status' => false,
        'current_user_id' => true,
        'current_user_role' => true,
        'approve_payout_url' => true,
        'created_by' => true,
        'created_by_email_address' => true,
        'inserted' => false,
        'source_account_name' => true,
        'source_account_iban' => true,
        'source_account_number' => true,
        'source_account_sortcode' => true,
        'source_bitcoin_address' => true,
        'source_account_identifier' => false,
        'source_account_available_balance' => true,
        'formatted_source_account_available_balance' => true,
        'destination' => false,
        'invoice_id' => true,
        'tags' => true,
        'scheduled' => true,
        'schedule_date' => true,
        'formatted_schedule_day_only' => true,
        'formatted_schedule' => true,
        'bitcoin_subtract_fee_from_amount' => false,
        'bitcoin_fee_sats_per_vbyte' => false,
        'formatted_bitcoin_fee' => true,
        'authorisers_required_count' => false,
        'authorisers_completed_count' => false,
        'can_authorise' => false,
        'can_update' => false,
        'has_current_user_authorised' => false,
        'authorised_by' => true,
        'payrun_name' => true,
        'beneficiary' => false,
        'payment_processor' => false,
        'events' => true,
        'rule' => false,
        'payment_rail' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'payrun_id' => 'payrunID',
        'account_id' => 'accountID',
        'merchant_id' => 'merchantID',
        'user_id' => 'userID',
        'approver_id' => 'approverID',
        'topup_payrun_id' => 'topupPayrunID',
        'type' => 'type',
        'description' => 'description',
        'currency' => 'currency',
        'amount' => 'amount',
        'formatted_amount' => 'formattedAmount',
        'your_reference' => 'yourReference',
        'their_reference' => 'theirReference',
        'can_process' => 'canProcess',
        'batch_payout_id' => 'batchPayoutID',
        'merchant_token_description' => 'merchantTokenDescription',
        'status' => 'status',
        'current_user_id' => 'currentUserID',
        'current_user_role' => 'currentUserRole',
        'approve_payout_url' => 'approvePayoutUrl',
        'created_by' => 'createdBy',
        'created_by_email_address' => 'createdByEmailAddress',
        'inserted' => 'inserted',
        'source_account_name' => 'sourceAccountName',
        'source_account_iban' => 'sourceAccountIban',
        'source_account_number' => 'sourceAccountNumber',
        'source_account_sortcode' => 'sourceAccountSortcode',
        'source_bitcoin_address' => 'sourceBitcoinAddress',
        'source_account_identifier' => 'sourceAccountIdentifier',
        'source_account_available_balance' => 'sourceAccountAvailableBalance',
        'formatted_source_account_available_balance' => 'formattedSourceAccountAvailableBalance',
        'destination' => 'destination',
        'invoice_id' => 'invoiceID',
        'tags' => 'tags',
        'scheduled' => 'scheduled',
        'schedule_date' => 'scheduleDate',
        'formatted_schedule_day_only' => 'formattedScheduleDayOnly',
        'formatted_schedule' => 'formattedSchedule',
        'bitcoin_subtract_fee_from_amount' => 'bitcoinSubtractFeeFromAmount',
        'bitcoin_fee_sats_per_vbyte' => 'bitcoinFeeSatsPerVbyte',
        'formatted_bitcoin_fee' => 'formattedBitcoinFee',
        'authorisers_required_count' => 'authorisersRequiredCount',
        'authorisers_completed_count' => 'authorisersCompletedCount',
        'can_authorise' => 'canAuthorise',
        'can_update' => 'canUpdate',
        'has_current_user_authorised' => 'hasCurrentUserAuthorised',
        'authorised_by' => 'authorisedBy',
        'payrun_name' => 'payrunName',
        'beneficiary' => 'beneficiary',
        'payment_processor' => 'paymentProcessor',
        'events' => 'events',
        'rule' => 'rule',
        'payment_rail' => 'paymentRail'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'payrun_id' => 'setPayrunId',
        'account_id' => 'setAccountId',
        'merchant_id' => 'setMerchantId',
        'user_id' => 'setUserId',
        'approver_id' => 'setApproverId',
        'topup_payrun_id' => 'setTopupPayrunId',
        'type' => 'setType',
        'description' => 'setDescription',
        'currency' => 'setCurrency',
        'amount' => 'setAmount',
        'formatted_amount' => 'setFormattedAmount',
        'your_reference' => 'setYourReference',
        'their_reference' => 'setTheirReference',
        'can_process' => 'setCanProcess',
        'batch_payout_id' => 'setBatchPayoutId',
        'merchant_token_description' => 'setMerchantTokenDescription',
        'status' => 'setStatus',
        'current_user_id' => 'setCurrentUserId',
        'current_user_role' => 'setCurrentUserRole',
        'approve_payout_url' => 'setApprovePayoutUrl',
        'created_by' => 'setCreatedBy',
        'created_by_email_address' => 'setCreatedByEmailAddress',
        'inserted' => 'setInserted',
        'source_account_name' => 'setSourceAccountName',
        'source_account_iban' => 'setSourceAccountIban',
        'source_account_number' => 'setSourceAccountNumber',
        'source_account_sortcode' => 'setSourceAccountSortcode',
        'source_bitcoin_address' => 'setSourceBitcoinAddress',
        'source_account_identifier' => 'setSourceAccountIdentifier',
        'source_account_available_balance' => 'setSourceAccountAvailableBalance',
        'formatted_source_account_available_balance' => 'setFormattedSourceAccountAvailableBalance',
        'destination' => 'setDestination',
        'invoice_id' => 'setInvoiceId',
        'tags' => 'setTags',
        'scheduled' => 'setScheduled',
        'schedule_date' => 'setScheduleDate',
        'formatted_schedule_day_only' => 'setFormattedScheduleDayOnly',
        'formatted_schedule' => 'setFormattedSchedule',
        'bitcoin_subtract_fee_from_amount' => 'setBitcoinSubtractFeeFromAmount',
        'bitcoin_fee_sats_per_vbyte' => 'setBitcoinFeeSatsPerVbyte',
        'formatted_bitcoin_fee' => 'setFormattedBitcoinFee',
        'authorisers_required_count' => 'setAuthorisersRequiredCount',
        'authorisers_completed_count' => 'setAuthorisersCompletedCount',
        'can_authorise' => 'setCanAuthorise',
        'can_update' => 'setCanUpdate',
        'has_current_user_authorised' => 'setHasCurrentUserAuthorised',
        'authorised_by' => 'setAuthorisedBy',
        'payrun_name' => 'setPayrunName',
        'beneficiary' => 'setBeneficiary',
        'payment_processor' => 'setPaymentProcessor',
        'events' => 'setEvents',
        'rule' => 'setRule',
        'payment_rail' => 'setPaymentRail'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'payrun_id' => 'getPayrunId',
        'account_id' => 'getAccountId',
        'merchant_id' => 'getMerchantId',
        'user_id' => 'getUserId',
        'approver_id' => 'getApproverId',
        'topup_payrun_id' => 'getTopupPayrunId',
        'type' => 'getType',
        'description' => 'getDescription',
        'currency' => 'getCurrency',
        'amount' => 'getAmount',
        'formatted_amount' => 'getFormattedAmount',
        'your_reference' => 'getYourReference',
        'their_reference' => 'getTheirReference',
        'can_process' => 'getCanProcess',
        'batch_payout_id' => 'getBatchPayoutId',
        'merchant_token_description' => 'getMerchantTokenDescription',
        'status' => 'getStatus',
        'current_user_id' => 'getCurrentUserId',
        'current_user_role' => 'getCurrentUserRole',
        'approve_payout_url' => 'getApprovePayoutUrl',
        'created_by' => 'getCreatedBy',
        'created_by_email_address' => 'getCreatedByEmailAddress',
        'inserted' => 'getInserted',
        'source_account_name' => 'getSourceAccountName',
        'source_account_iban' => 'getSourceAccountIban',
        'source_account_number' => 'getSourceAccountNumber',
        'source_account_sortcode' => 'getSourceAccountSortcode',
        'source_bitcoin_address' => 'getSourceBitcoinAddress',
        'source_account_identifier' => 'getSourceAccountIdentifier',
        'source_account_available_balance' => 'getSourceAccountAvailableBalance',
        'formatted_source_account_available_balance' => 'getFormattedSourceAccountAvailableBalance',
        'destination' => 'getDestination',
        'invoice_id' => 'getInvoiceId',
        'tags' => 'getTags',
        'scheduled' => 'getScheduled',
        'schedule_date' => 'getScheduleDate',
        'formatted_schedule_day_only' => 'getFormattedScheduleDayOnly',
        'formatted_schedule' => 'getFormattedSchedule',
        'bitcoin_subtract_fee_from_amount' => 'getBitcoinSubtractFeeFromAmount',
        'bitcoin_fee_sats_per_vbyte' => 'getBitcoinFeeSatsPerVbyte',
        'formatted_bitcoin_fee' => 'getFormattedBitcoinFee',
        'authorisers_required_count' => 'getAuthorisersRequiredCount',
        'authorisers_completed_count' => 'getAuthorisersCompletedCount',
        'can_authorise' => 'getCanAuthorise',
        'can_update' => 'getCanUpdate',
        'has_current_user_authorised' => 'getHasCurrentUserAuthorised',
        'authorised_by' => 'getAuthorisedBy',
        'payrun_name' => 'getPayrunName',
        'beneficiary' => 'getBeneficiary',
        'payment_processor' => 'getPaymentProcessor',
        'events' => 'getEvents',
        'rule' => 'getRule',
        'payment_rail' => 'getPaymentRail'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_UNKNOWN = 'Unknown';
    public const TYPE_SCAN = 'SCAN';
    public const TYPE_IBAN = 'IBAN';
    public const TYPE_DD = 'DD';
    public const TYPE_BTC = 'BTC';
    public const CURRENCY_NONE = 'NONE';
    public const CURRENCY_GBP = 'GBP';
    public const CURRENCY_EUR = 'EUR';
    public const CURRENCY_BTC = 'BTC';
    public const STATUS_UNKNOWN = 'UNKNOWN';
    public const STATUS_REJECTED = 'REJECTED';
    public const STATUS_PENDING = 'PENDING';
    public const STATUS_PROCESSED = 'PROCESSED';
    public const STATUS_PENDING_APPROVAL = 'PENDING_APPROVAL';
    public const STATUS_QUEUED_UPSTREAM = 'QUEUED_UPSTREAM';
    public const STATUS_QUEUED = 'QUEUED';
    public const STATUS_FAILED = 'FAILED';
    public const STATUS_PENDING_INPUT = 'PENDING_INPUT';
    public const STATUS_SCHEDULED = 'SCHEDULED';
    public const STATUS_REJECTED_APPROVAL = 'REJECTED_APPROVAL';
    public const CURRENT_USER_ROLE_NEWLY_REGISTERED = 'NewlyRegistered';
    public const CURRENT_USER_ROLE_PAYMENT_REQUESTOR = 'PaymentRequestor';
    public const CURRENT_USER_ROLE_USER = 'User';
    public const CURRENT_USER_ROLE_APPROVER = 'Approver';
    public const CURRENT_USER_ROLE_ADMIN_APPROVER = 'AdminApprover';
    public const PAYMENT_PROCESSOR_NONE = 'None';
    public const PAYMENT_PROCESSOR_CYBER_SOURCE = 'CyberSource';
    public const PAYMENT_PROCESSOR_CHECKOUT = 'Checkout';
    public const PAYMENT_PROCESSOR_STRIPE = 'Stripe';
    public const PAYMENT_PROCESSOR_MODULR = 'Modulr';
    public const PAYMENT_PROCESSOR_PLAID = 'Plaid';
    public const PAYMENT_PROCESSOR_YAPILY = 'Yapily';
    public const PAYMENT_PROCESSOR_NOFRIXION = 'Nofrixion';
    public const PAYMENT_PROCESSOR_BITCOIN = 'Bitcoin';
    public const PAYMENT_PROCESSOR_BITCOIN_TESTNET = 'BitcoinTestnet';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE = 'BankingCircle';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE_AGENCY = 'BankingCircleAgency';
    public const PAYMENT_PROCESSOR_SIMULATOR = 'Simulator';
    public const PAYMENT_PROCESSOR_LIGHTNING = 'Lightning';
    public const PAYMENT_PROCESSOR_LIGHTNING_TESTNET = 'LightningTestnet';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE_DIRECT_DEBIT = 'BankingCircleDirectDebit';
    public const PAYMENT_PROCESSOR_TRIBE = 'Tribe';
    public const PAYMENT_RAIL__DEFAULT = 'Default';
    public const PAYMENT_RAIL_SEPA_CT = 'SEPA_CT';
    public const PAYMENT_RAIL_SEPA_INST = 'SEPA_INST';
    public const PAYMENT_RAIL_TARGET2 = 'TARGET2';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_UNKNOWN,
            self::TYPE_SCAN,
            self::TYPE_IBAN,
            self::TYPE_DD,
            self::TYPE_BTC,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCurrencyAllowableValues()
    {
        return [
            self::CURRENCY_NONE,
            self::CURRENCY_GBP,
            self::CURRENCY_EUR,
            self::CURRENCY_BTC,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_UNKNOWN,
            self::STATUS_REJECTED,
            self::STATUS_PENDING,
            self::STATUS_PROCESSED,
            self::STATUS_PENDING_APPROVAL,
            self::STATUS_QUEUED_UPSTREAM,
            self::STATUS_QUEUED,
            self::STATUS_FAILED,
            self::STATUS_PENDING_INPUT,
            self::STATUS_SCHEDULED,
            self::STATUS_REJECTED_APPROVAL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCurrentUserRoleAllowableValues()
    {
        return [
            self::CURRENT_USER_ROLE_NEWLY_REGISTERED,
            self::CURRENT_USER_ROLE_PAYMENT_REQUESTOR,
            self::CURRENT_USER_ROLE_USER,
            self::CURRENT_USER_ROLE_APPROVER,
            self::CURRENT_USER_ROLE_ADMIN_APPROVER,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentProcessorAllowableValues()
    {
        return [
            self::PAYMENT_PROCESSOR_NONE,
            self::PAYMENT_PROCESSOR_CYBER_SOURCE,
            self::PAYMENT_PROCESSOR_CHECKOUT,
            self::PAYMENT_PROCESSOR_STRIPE,
            self::PAYMENT_PROCESSOR_MODULR,
            self::PAYMENT_PROCESSOR_PLAID,
            self::PAYMENT_PROCESSOR_YAPILY,
            self::PAYMENT_PROCESSOR_NOFRIXION,
            self::PAYMENT_PROCESSOR_BITCOIN,
            self::PAYMENT_PROCESSOR_BITCOIN_TESTNET,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE_AGENCY,
            self::PAYMENT_PROCESSOR_SIMULATOR,
            self::PAYMENT_PROCESSOR_LIGHTNING,
            self::PAYMENT_PROCESSOR_LIGHTNING_TESTNET,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE_DIRECT_DEBIT,
            self::PAYMENT_PROCESSOR_TRIBE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentRailAllowableValues()
    {
        return [
            self::PAYMENT_RAIL__DEFAULT,
            self::PAYMENT_RAIL_SEPA_CT,
            self::PAYMENT_RAIL_SEPA_INST,
            self::PAYMENT_RAIL_TARGET2,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('payrun_id', $data ?? [], null);
        $this->setIfExists('account_id', $data ?? [], null);
        $this->setIfExists('merchant_id', $data ?? [], null);
        $this->setIfExists('user_id', $data ?? [], null);
        $this->setIfExists('approver_id', $data ?? [], null);
        $this->setIfExists('topup_payrun_id', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('formatted_amount', $data ?? [], null);
        $this->setIfExists('your_reference', $data ?? [], null);
        $this->setIfExists('their_reference', $data ?? [], null);
        $this->setIfExists('can_process', $data ?? [], null);
        $this->setIfExists('batch_payout_id', $data ?? [], null);
        $this->setIfExists('merchant_token_description', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('current_user_id', $data ?? [], null);
        $this->setIfExists('current_user_role', $data ?? [], null);
        $this->setIfExists('approve_payout_url', $data ?? [], null);
        $this->setIfExists('created_by', $data ?? [], null);
        $this->setIfExists('created_by_email_address', $data ?? [], null);
        $this->setIfExists('inserted', $data ?? [], null);
        $this->setIfExists('source_account_name', $data ?? [], null);
        $this->setIfExists('source_account_iban', $data ?? [], null);
        $this->setIfExists('source_account_number', $data ?? [], null);
        $this->setIfExists('source_account_sortcode', $data ?? [], null);
        $this->setIfExists('source_bitcoin_address', $data ?? [], null);
        $this->setIfExists('source_account_identifier', $data ?? [], null);
        $this->setIfExists('source_account_available_balance', $data ?? [], null);
        $this->setIfExists('formatted_source_account_available_balance', $data ?? [], null);
        $this->setIfExists('destination', $data ?? [], null);
        $this->setIfExists('invoice_id', $data ?? [], null);
        $this->setIfExists('tags', $data ?? [], null);
        $this->setIfExists('scheduled', $data ?? [], null);
        $this->setIfExists('schedule_date', $data ?? [], null);
        $this->setIfExists('formatted_schedule_day_only', $data ?? [], null);
        $this->setIfExists('formatted_schedule', $data ?? [], null);
        $this->setIfExists('bitcoin_subtract_fee_from_amount', $data ?? [], null);
        $this->setIfExists('bitcoin_fee_sats_per_vbyte', $data ?? [], null);
        $this->setIfExists('formatted_bitcoin_fee', $data ?? [], null);
        $this->setIfExists('authorisers_required_count', $data ?? [], null);
        $this->setIfExists('authorisers_completed_count', $data ?? [], null);
        $this->setIfExists('can_authorise', $data ?? [], null);
        $this->setIfExists('can_update', $data ?? [], null);
        $this->setIfExists('has_current_user_authorised', $data ?? [], null);
        $this->setIfExists('authorised_by', $data ?? [], null);
        $this->setIfExists('payrun_name', $data ?? [], null);
        $this->setIfExists('beneficiary', $data ?? [], null);
        $this->setIfExists('payment_processor', $data ?? [], null);
        $this->setIfExists('events', $data ?? [], null);
        $this->setIfExists('rule', $data ?? [], null);
        $this->setIfExists('payment_rail', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCurrencyAllowableValues();
        if (!is_null($this->container['currency']) && !in_array($this->container['currency'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'currency', must be one of '%s'",
                $this->container['currency'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCurrentUserRoleAllowableValues();
        if (!is_null($this->container['current_user_role']) && !in_array($this->container['current_user_role'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'current_user_role', must be one of '%s'",
                $this->container['current_user_role'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPaymentProcessorAllowableValues();
        if (!is_null($this->container['payment_processor']) && !in_array($this->container['payment_processor'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_processor', must be one of '%s'",
                $this->container['payment_processor'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPaymentRailAllowableValues();
        if (!is_null($this->container['payment_rail']) && !in_array($this->container['payment_rail'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_rail', must be one of '%s'",
                $this->container['payment_rail'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id The ID for the payout.
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets payrun_id
     *
     * @return string|null
     */
    public function getPayrunId()
    {
        return $this->container['payrun_id'];
    }

    /**
     * Sets payrun_id
     *
     * @param string|null $payrun_id The ID of the payrun that this payout is associated with.
     *
     * @return self
     */
    public function setPayrunId($payrun_id)
    {
        if (is_null($payrun_id)) {
            array_push($this->openAPINullablesSetToNull, 'payrun_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payrun_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payrun_id'] = $payrun_id;

        return $this;
    }

    /**
     * Gets account_id
     *
     * @return string|null
     */
    public function getAccountId()
    {
        return $this->container['account_id'];
    }

    /**
     * Sets account_id
     *
     * @param string|null $account_id Gets or Sets Account Id of sending account
     *
     * @return self
     */
    public function setAccountId($account_id)
    {
        if (is_null($account_id)) {
            throw new \InvalidArgumentException('non-nullable account_id cannot be null');
        }
        $this->container['account_id'] = $account_id;

        return $this;
    }

    /**
     * Gets merchant_id
     *
     * @return string|null
     */
    public function getMerchantId()
    {
        return $this->container['merchant_id'];
    }

    /**
     * Sets merchant_id
     *
     * @param string|null $merchant_id The ID of the merchant that owns the account.
     *
     * @return self
     */
    public function setMerchantId($merchant_id)
    {
        if (is_null($merchant_id)) {
            throw new \InvalidArgumentException('non-nullable merchant_id cannot be null');
        }
        $this->container['merchant_id'] = $merchant_id;

        return $this;
    }

    /**
     * Gets user_id
     *
     * @return string|null
     */
    public function getUserId()
    {
        return $this->container['user_id'];
    }

    /**
     * Sets user_id
     *
     * @param string|null $user_id Gets or Sets User ID of who created the payout request
     *
     * @return self
     */
    public function setUserId($user_id)
    {
        if (is_null($user_id)) {
            array_push($this->openAPINullablesSetToNull, 'user_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('user_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['user_id'] = $user_id;

        return $this;
    }

    /**
     * Gets approver_id
     *
     * @return string|null
     */
    public function getApproverId()
    {
        return $this->container['approver_id'];
    }

    /**
     * Sets approver_id
     *
     * @param string|null $approver_id Gets the User ID of person that approved the payout.
     *
     * @return self
     */
    public function setApproverId($approver_id)
    {
        if (is_null($approver_id)) {
            array_push($this->openAPINullablesSetToNull, 'approver_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('approver_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['approver_id'] = $approver_id;

        return $this;
    }

    /**
     * Gets topup_payrun_id
     *
     * @return string|null
     */
    public function getTopupPayrunId()
    {
        return $this->container['topup_payrun_id'];
    }

    /**
     * Sets topup_payrun_id
     *
     * @param string|null $topup_payrun_id The ID of a payrun that needs an account top up.   Payouts can be used to top up payrun accounts.
     *
     * @return self
     */
    public function setTopupPayrunId($topup_payrun_id)
    {
        if (is_null($topup_payrun_id)) {
            array_push($this->openAPINullablesSetToNull, 'topup_payrun_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('topup_payrun_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['topup_payrun_id'] = $topup_payrun_id;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type Gets or Sets payout type
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description Gets or Sets description of payout request
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            array_push($this->openAPINullablesSetToNull, 'description');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('description', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency Gets or Sets Currency of payout request
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        $allowedValues = $this->getCurrencyAllowableValues();
        if (!in_array($currency, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'currency', must be one of '%s'",
                    $currency,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return float|null
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param float|null $amount Gets or Sets payout amount
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets formatted_amount
     *
     * @return string|null
     */
    public function getFormattedAmount()
    {
        return $this->container['formatted_amount'];
    }

    /**
     * Sets formatted_amount
     *
     * @param string|null $formatted_amount Currency and formatted amount string.
     *
     * @return self
     */
    public function setFormattedAmount($formatted_amount)
    {
        if (is_null($formatted_amount)) {
            array_push($this->openAPINullablesSetToNull, 'formatted_amount');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('formatted_amount', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['formatted_amount'] = $formatted_amount;

        return $this;
    }

    /**
     * Gets your_reference
     *
     * @return string|null
     */
    public function getYourReference()
    {
        return $this->container['your_reference'];
    }

    /**
     * Sets your_reference
     *
     * @param string|null $your_reference Gets or Sets your reference ID
     *
     * @return self
     */
    public function setYourReference($your_reference)
    {
        if (is_null($your_reference)) {
            array_push($this->openAPINullablesSetToNull, 'your_reference');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('your_reference', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['your_reference'] = $your_reference;

        return $this;
    }

    /**
     * Gets their_reference
     *
     * @return string|null
     */
    public function getTheirReference()
    {
        return $this->container['their_reference'];
    }

    /**
     * Sets their_reference
     *
     * @param string|null $their_reference Gets or Sets destination reference ID
     *
     * @return self
     */
    public function setTheirReference($their_reference)
    {
        if (is_null($their_reference)) {
            array_push($this->openAPINullablesSetToNull, 'their_reference');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('their_reference', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['their_reference'] = $their_reference;

        return $this;
    }

    /**
     * Gets can_process
     *
     * @return bool|null
     */
    public function getCanProcess()
    {
        return $this->container['can_process'];
    }

    /**
     * Sets can_process
     *
     * @param bool|null $can_process If set to true indicates the payout has been flagged as safe to process after transaction monitoring.
     *
     * @return self
     */
    public function setCanProcess($can_process)
    {
        if (is_null($can_process)) {
            throw new \InvalidArgumentException('non-nullable can_process cannot be null');
        }
        $this->container['can_process'] = $can_process;

        return $this;
    }

    /**
     * Gets batch_payout_id
     *
     * @return string|null
     */
    public function getBatchPayoutId()
    {
        return $this->container['batch_payout_id'];
    }

    /**
     * Sets batch_payout_id
     *
     * @param string|null $batch_payout_id The ID of the batch the payout is associated with.
     *
     * @return self
     */
    public function setBatchPayoutId($batch_payout_id)
    {
        if (is_null($batch_payout_id)) {
            array_push($this->openAPINullablesSetToNull, 'batch_payout_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('batch_payout_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['batch_payout_id'] = $batch_payout_id;

        return $this;
    }

    /**
     * Gets merchant_token_description
     *
     * @return string|null
     */
    public function getMerchantTokenDescription()
    {
        return $this->container['merchant_token_description'];
    }

    /**
     * Sets merchant_token_description
     *
     * @param string|null $merchant_token_description merchant_token_description
     *
     * @return self
     */
    public function setMerchantTokenDescription($merchant_token_description)
    {
        if (is_null($merchant_token_description)) {
            array_push($this->openAPINullablesSetToNull, 'merchant_token_description');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('merchant_token_description', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['merchant_token_description'] = $merchant_token_description;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status Gets or Sets the status of payout request
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets current_user_id
     *
     * @return string|null
     */
    public function getCurrentUserId()
    {
        return $this->container['current_user_id'];
    }

    /**
     * Sets current_user_id
     *
     * @param string|null $current_user_id The ID of the user that requested access to the PayOut record. Note  this is NOT necessarily the user that created it.
     *
     * @return self
     */
    public function setCurrentUserId($current_user_id)
    {
        if (is_null($current_user_id)) {
            array_push($this->openAPINullablesSetToNull, 'current_user_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('current_user_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['current_user_id'] = $current_user_id;

        return $this;
    }

    /**
     * Gets current_user_role
     *
     * @return string|null
     */
    public function getCurrentUserRole()
    {
        return $this->container['current_user_role'];
    }

    /**
     * Sets current_user_role
     *
     * @param string|null $current_user_role The role of the user that requested access to the PayOut record. Note  this is NOT necessarily the user that created it. For example one user  may create the payout and then a different user will load the record to  approve it.
     *
     * @return self
     */
    public function setCurrentUserRole($current_user_role)
    {
        if (is_null($current_user_role)) {
            array_push($this->openAPINullablesSetToNull, 'current_user_role');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('current_user_role', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getCurrentUserRoleAllowableValues();
        if (!is_null($current_user_role) && !in_array($current_user_role, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'current_user_role', must be one of '%s'",
                    $current_user_role,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['current_user_role'] = $current_user_role;

        return $this;
    }

    /**
     * Gets approve_payout_url
     *
     * @return string|null
     */
    public function getApprovePayoutUrl()
    {
        return $this->container['approve_payout_url'];
    }

    /**
     * Sets approve_payout_url
     *
     * @param string|null $approve_payout_url This field is used when returning an payout record to a client. If set it holds the URL  the user needs to visit in order to complete a strong authentication check in order to approve   the payout.
     *
     * @return self
     */
    public function setApprovePayoutUrl($approve_payout_url)
    {
        if (is_null($approve_payout_url)) {
            array_push($this->openAPINullablesSetToNull, 'approve_payout_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('approve_payout_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['approve_payout_url'] = $approve_payout_url;

        return $this;
    }

    /**
     * Gets created_by
     *
     * @return string|null
     */
    public function getCreatedBy()
    {
        return $this->container['created_by'];
    }

    /**
     * Sets created_by
     *
     * @param string|null $created_by created_by
     *
     * @return self
     */
    public function setCreatedBy($created_by)
    {
        if (is_null($created_by)) {
            array_push($this->openAPINullablesSetToNull, 'created_by');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('created_by', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['created_by'] = $created_by;

        return $this;
    }

    /**
     * Gets created_by_email_address
     *
     * @return string|null
     */
    public function getCreatedByEmailAddress()
    {
        return $this->container['created_by_email_address'];
    }

    /**
     * Sets created_by_email_address
     *
     * @param string|null $created_by_email_address created_by_email_address
     *
     * @return self
     */
    public function setCreatedByEmailAddress($created_by_email_address)
    {
        if (is_null($created_by_email_address)) {
            array_push($this->openAPINullablesSetToNull, 'created_by_email_address');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('created_by_email_address', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['created_by_email_address'] = $created_by_email_address;

        return $this;
    }

    /**
     * Gets inserted
     *
     * @return \DateTime|null
     */
    public function getInserted()
    {
        return $this->container['inserted'];
    }

    /**
     * Sets inserted
     *
     * @param \DateTime|null $inserted inserted
     *
     * @return self
     */
    public function setInserted($inserted)
    {
        if (is_null($inserted)) {
            throw new \InvalidArgumentException('non-nullable inserted cannot be null');
        }
        $this->container['inserted'] = $inserted;

        return $this;
    }

    /**
     * Gets source_account_name
     *
     * @return string|null
     */
    public function getSourceAccountName()
    {
        return $this->container['source_account_name'];
    }

    /**
     * Sets source_account_name
     *
     * @param string|null $source_account_name The name of the account the payout is being made from.
     *
     * @return self
     */
    public function setSourceAccountName($source_account_name)
    {
        if (is_null($source_account_name)) {
            array_push($this->openAPINullablesSetToNull, 'source_account_name');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('source_account_name', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['source_account_name'] = $source_account_name;

        return $this;
    }

    /**
     * Gets source_account_iban
     *
     * @return string|null
     */
    public function getSourceAccountIban()
    {
        return $this->container['source_account_iban'];
    }

    /**
     * Sets source_account_iban
     *
     * @param string|null $source_account_iban The IBAN of the account the payout is being made from.
     *
     * @return self
     */
    public function setSourceAccountIban($source_account_iban)
    {
        if (is_null($source_account_iban)) {
            array_push($this->openAPINullablesSetToNull, 'source_account_iban');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('source_account_iban', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['source_account_iban'] = $source_account_iban;

        return $this;
    }

    /**
     * Gets source_account_number
     *
     * @return string|null
     */
    public function getSourceAccountNumber()
    {
        return $this->container['source_account_number'];
    }

    /**
     * Sets source_account_number
     *
     * @param string|null $source_account_number The account number of the account the payout is being made from.
     *
     * @return self
     */
    public function setSourceAccountNumber($source_account_number)
    {
        if (is_null($source_account_number)) {
            array_push($this->openAPINullablesSetToNull, 'source_account_number');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('source_account_number', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['source_account_number'] = $source_account_number;

        return $this;
    }

    /**
     * Gets source_account_sortcode
     *
     * @return string|null
     */
    public function getSourceAccountSortcode()
    {
        return $this->container['source_account_sortcode'];
    }

    /**
     * Sets source_account_sortcode
     *
     * @param string|null $source_account_sortcode The sort code of the account the payout is being made from.
     *
     * @return self
     */
    public function setSourceAccountSortcode($source_account_sortcode)
    {
        if (is_null($source_account_sortcode)) {
            array_push($this->openAPINullablesSetToNull, 'source_account_sortcode');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('source_account_sortcode', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['source_account_sortcode'] = $source_account_sortcode;

        return $this;
    }

    /**
     * Gets source_bitcoin_address
     *
     * @return string|null
     */
    public function getSourceBitcoinAddress()
    {
        return $this->container['source_bitcoin_address'];
    }

    /**
     * Sets source_bitcoin_address
     *
     * @param string|null $source_bitcoin_address The current Bitcoin address of the account the payout is being made from.
     *
     * @return self
     */
    public function setSourceBitcoinAddress($source_bitcoin_address)
    {
        if (is_null($source_bitcoin_address)) {
            array_push($this->openAPINullablesSetToNull, 'source_bitcoin_address');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('source_bitcoin_address', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['source_bitcoin_address'] = $source_bitcoin_address;

        return $this;
    }

    /**
     * Gets source_account_identifier
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsAccountIdentifier|null
     */
    public function getSourceAccountIdentifier()
    {
        return $this->container['source_account_identifier'];
    }

    /**
     * Sets source_account_identifier
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsAccountIdentifier|null $source_account_identifier source_account_identifier
     *
     * @return self
     */
    public function setSourceAccountIdentifier($source_account_identifier)
    {
        if (is_null($source_account_identifier)) {
            throw new \InvalidArgumentException('non-nullable source_account_identifier cannot be null');
        }
        $this->container['source_account_identifier'] = $source_account_identifier;

        return $this;
    }

    /**
     * Gets source_account_available_balance
     *
     * @return float|null
     */
    public function getSourceAccountAvailableBalance()
    {
        return $this->container['source_account_available_balance'];
    }

    /**
     * Sets source_account_available_balance
     *
     * @param float|null $source_account_available_balance The available balance of the account the payout is being made from.
     *
     * @return self
     */
    public function setSourceAccountAvailableBalance($source_account_available_balance)
    {
        if (is_null($source_account_available_balance)) {
            array_push($this->openAPINullablesSetToNull, 'source_account_available_balance');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('source_account_available_balance', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['source_account_available_balance'] = $source_account_available_balance;

        return $this;
    }

    /**
     * Gets formatted_source_account_available_balance
     *
     * @return string|null
     */
    public function getFormattedSourceAccountAvailableBalance()
    {
        return $this->container['formatted_source_account_available_balance'];
    }

    /**
     * Sets formatted_source_account_available_balance
     *
     * @param string|null $formatted_source_account_available_balance The available balance of the account the payout is being made from.
     *
     * @return self
     */
    public function setFormattedSourceAccountAvailableBalance($formatted_source_account_available_balance)
    {
        if (is_null($formatted_source_account_available_balance)) {
            array_push($this->openAPINullablesSetToNull, 'formatted_source_account_available_balance');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('formatted_source_account_available_balance', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['formatted_source_account_available_balance'] = $formatted_source_account_available_balance;

        return $this;
    }

    /**
     * Gets destination
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsCounterparty|null
     */
    public function getDestination()
    {
        return $this->container['destination'];
    }

    /**
     * Sets destination
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsCounterparty|null $destination destination
     *
     * @return self
     */
    public function setDestination($destination)
    {
        if (is_null($destination)) {
            throw new \InvalidArgumentException('non-nullable destination cannot be null');
        }
        $this->container['destination'] = $destination;

        return $this;
    }

    /**
     * Gets invoice_id
     *
     * @return string|null
     */
    public function getInvoiceId()
    {
        return $this->container['invoice_id'];
    }

    /**
     * Sets invoice_id
     *
     * @param string|null $invoice_id Optional field to associate the payout with the invoice from an external   application such as Xero. The InvoiceID needs to be unique for each  account.
     *
     * @return self
     */
    public function setInvoiceId($invoice_id)
    {
        if (is_null($invoice_id)) {
            array_push($this->openAPINullablesSetToNull, 'invoice_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('invoice_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['invoice_id'] = $invoice_id;

        return $this;
    }

    /**
     * Gets tags
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTag[]|null
     */
    public function getTags()
    {
        return $this->container['tags'];
    }

    /**
     * Sets tags
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTag[]|null $tags An optional list of descriptive tags attached to the payout.
     *
     * @return self
     */
    public function setTags($tags)
    {
        if (is_null($tags)) {
            array_push($this->openAPINullablesSetToNull, 'tags');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tags', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tags'] = $tags;

        return $this;
    }

    /**
     * Gets scheduled
     *
     * @return bool|null
     */
    public function getScheduled()
    {
        return $this->container['scheduled'];
    }

    /**
     * Sets scheduled
     *
     * @param bool|null $scheduled Should this payout be scheduled for a future date?
     *
     * @return self
     */
    public function setScheduled($scheduled)
    {
        if (is_null($scheduled)) {
            array_push($this->openAPINullablesSetToNull, 'scheduled');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('scheduled', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['scheduled'] = $scheduled;

        return $this;
    }

    /**
     * Gets schedule_date
     *
     * @return \DateTime|null
     */
    public function getScheduleDate()
    {
        return $this->container['schedule_date'];
    }

    /**
     * Sets schedule_date
     *
     * @param \DateTime|null $schedule_date The date the payout should be submitted.
     *
     * @return self
     */
    public function setScheduleDate($schedule_date)
    {
        if (is_null($schedule_date)) {
            array_push($this->openAPINullablesSetToNull, 'schedule_date');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('schedule_date', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['schedule_date'] = $schedule_date;

        return $this;
    }

    /**
     * Gets formatted_schedule_day_only
     *
     * @return string|null
     */
    public function getFormattedScheduleDayOnly()
    {
        return $this->container['formatted_schedule_day_only'];
    }

    /**
     * Sets formatted_schedule_day_only
     *
     * @param string|null $formatted_schedule_day_only formatted_schedule_day_only
     *
     * @return self
     */
    public function setFormattedScheduleDayOnly($formatted_schedule_day_only)
    {
        if (is_null($formatted_schedule_day_only)) {
            array_push($this->openAPINullablesSetToNull, 'formatted_schedule_day_only');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('formatted_schedule_day_only', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['formatted_schedule_day_only'] = $formatted_schedule_day_only;

        return $this;
    }

    /**
     * Gets formatted_schedule
     *
     * @return string|null
     */
    public function getFormattedSchedule()
    {
        return $this->container['formatted_schedule'];
    }

    /**
     * Sets formatted_schedule
     *
     * @param string|null $formatted_schedule formatted_schedule
     *
     * @return self
     */
    public function setFormattedSchedule($formatted_schedule)
    {
        if (is_null($formatted_schedule)) {
            array_push($this->openAPINullablesSetToNull, 'formatted_schedule');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('formatted_schedule', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['formatted_schedule'] = $formatted_schedule;

        return $this;
    }

    /**
     * Gets bitcoin_subtract_fee_from_amount
     *
     * @return bool|null
     */
    public function getBitcoinSubtractFeeFromAmount()
    {
        return $this->container['bitcoin_subtract_fee_from_amount'];
    }

    /**
     * Sets bitcoin_subtract_fee_from_amount
     *
     * @param bool|null $bitcoin_subtract_fee_from_amount For Bitcoin payouts, when this flag is set the network fee will be deducted from the send amount.  THis is particularly useful for sweeps where it can be difficult to calculate the exact fee required.
     *
     * @return self
     */
    public function setBitcoinSubtractFeeFromAmount($bitcoin_subtract_fee_from_amount)
    {
        if (is_null($bitcoin_subtract_fee_from_amount)) {
            throw new \InvalidArgumentException('non-nullable bitcoin_subtract_fee_from_amount cannot be null');
        }
        $this->container['bitcoin_subtract_fee_from_amount'] = $bitcoin_subtract_fee_from_amount;

        return $this;
    }

    /**
     * Gets bitcoin_fee_sats_per_vbyte
     *
     * @return int|null
     */
    public function getBitcoinFeeSatsPerVbyte()
    {
        return $this->container['bitcoin_fee_sats_per_vbyte'];
    }

    /**
     * Sets bitcoin_fee_sats_per_vbyte
     *
     * @param int|null $bitcoin_fee_sats_per_vbyte The Bitcoin fee rate to apply in Satoshis per virtual byte.
     *
     * @return self
     */
    public function setBitcoinFeeSatsPerVbyte($bitcoin_fee_sats_per_vbyte)
    {
        if (is_null($bitcoin_fee_sats_per_vbyte)) {
            throw new \InvalidArgumentException('non-nullable bitcoin_fee_sats_per_vbyte cannot be null');
        }
        $this->container['bitcoin_fee_sats_per_vbyte'] = $bitcoin_fee_sats_per_vbyte;

        return $this;
    }

    /**
     * Gets formatted_bitcoin_fee
     *
     * @return string|null
     */
    public function getFormattedBitcoinFee()
    {
        return $this->container['formatted_bitcoin_fee'];
    }

    /**
     * Sets formatted_bitcoin_fee
     *
     * @param string|null $formatted_bitcoin_fee formatted_bitcoin_fee
     *
     * @return self
     */
    public function setFormattedBitcoinFee($formatted_bitcoin_fee)
    {
        if (is_null($formatted_bitcoin_fee)) {
            array_push($this->openAPINullablesSetToNull, 'formatted_bitcoin_fee');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('formatted_bitcoin_fee', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['formatted_bitcoin_fee'] = $formatted_bitcoin_fee;

        return $this;
    }

    /**
     * Gets authorisers_required_count
     *
     * @return int|null
     */
    public function getAuthorisersRequiredCount()
    {
        return $this->container['authorisers_required_count'];
    }

    /**
     * Sets authorisers_required_count
     *
     * @param int|null $authorisers_required_count The number of authorisers required for this payout. Is determined by business settings  on the source account and/or merchant.
     *
     * @return self
     */
    public function setAuthorisersRequiredCount($authorisers_required_count)
    {
        if (is_null($authorisers_required_count)) {
            throw new \InvalidArgumentException('non-nullable authorisers_required_count cannot be null');
        }
        $this->container['authorisers_required_count'] = $authorisers_required_count;

        return $this;
    }

    /**
     * Gets authorisers_completed_count
     *
     * @return int|null
     */
    public function getAuthorisersCompletedCount()
    {
        return $this->container['authorisers_completed_count'];
    }

    /**
     * Sets authorisers_completed_count
     *
     * @param int|null $authorisers_completed_count The number of distinct authorisers that have authorised the payout.
     *
     * @return self
     */
    public function setAuthorisersCompletedCount($authorisers_completed_count)
    {
        if (is_null($authorisers_completed_count)) {
            throw new \InvalidArgumentException('non-nullable authorisers_completed_count cannot be null');
        }
        $this->container['authorisers_completed_count'] = $authorisers_completed_count;

        return $this;
    }

    /**
     * Gets can_authorise
     *
     * @return bool|null
     */
    public function getCanAuthorise()
    {
        return $this->container['can_authorise'];
    }

    /**
     * Sets can_authorise
     *
     * @param bool|null $can_authorise True if the payout can be authorised by the user who loaded it.
     *
     * @return self
     */
    public function setCanAuthorise($can_authorise)
    {
        if (is_null($can_authorise)) {
            throw new \InvalidArgumentException('non-nullable can_authorise cannot be null');
        }
        $this->container['can_authorise'] = $can_authorise;

        return $this;
    }

    /**
     * Gets can_update
     *
     * @return bool|null
     */
    public function getCanUpdate()
    {
        return $this->container['can_update'];
    }

    /**
     * Sets can_update
     *
     * @param bool|null $can_update True if the payout can be updated by the user who loaded it.
     *
     * @return self
     */
    public function setCanUpdate($can_update)
    {
        if (is_null($can_update)) {
            throw new \InvalidArgumentException('non-nullable can_update cannot be null');
        }
        $this->container['can_update'] = $can_update;

        return $this;
    }

    /**
     * Gets has_current_user_authorised
     *
     * @return bool|null
     */
    public function getHasCurrentUserAuthorised()
    {
        return $this->container['has_current_user_authorised'];
    }

    /**
     * Sets has_current_user_authorised
     *
     * @param bool|null $has_current_user_authorised True if the payout was loaded for a user and that user has already authorised the latest version of the payout.
     *
     * @return self
     */
    public function setHasCurrentUserAuthorised($has_current_user_authorised)
    {
        if (is_null($has_current_user_authorised)) {
            throw new \InvalidArgumentException('non-nullable has_current_user_authorised cannot be null');
        }
        $this->container['has_current_user_authorised'] = $has_current_user_authorised;

        return $this;
    }

    /**
     * Gets authorised_by
     *
     * @return string[]|null
     */
    public function getAuthorisedBy()
    {
        return $this->container['authorised_by'];
    }

    /**
     * Sets authorised_by
     *
     * @param string[]|null $authorised_by A list of the email addresses of all the users who have usccessfully authorised the latest version of the payout.
     *
     * @return self
     */
    public function setAuthorisedBy($authorised_by)
    {
        if (is_null($authorised_by)) {
            array_push($this->openAPINullablesSetToNull, 'authorised_by');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('authorised_by', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['authorised_by'] = $authorised_by;

        return $this;
    }

    /**
     * Gets payrun_name
     *
     * @return string|null
     */
    public function getPayrunName()
    {
        return $this->container['payrun_name'];
    }

    /**
     * Sets payrun_name
     *
     * @param string|null $payrun_name The name of the payrun that this payout is associated with.
     *
     * @return self
     */
    public function setPayrunName($payrun_name)
    {
        if (is_null($payrun_name)) {
            array_push($this->openAPINullablesSetToNull, 'payrun_name');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payrun_name', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payrun_name'] = $payrun_name;

        return $this;
    }

    /**
     * Gets beneficiary
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsBeneficiary|null
     */
    public function getBeneficiary()
    {
        return $this->container['beneficiary'];
    }

    /**
     * Sets beneficiary
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsBeneficiary|null $beneficiary beneficiary
     *
     * @return self
     */
    public function setBeneficiary($beneficiary)
    {
        if (is_null($beneficiary)) {
            throw new \InvalidArgumentException('non-nullable beneficiary cannot be null');
        }
        $this->container['beneficiary'] = $beneficiary;

        return $this;
    }

    /**
     * Gets payment_processor
     *
     * @return string|null
     */
    public function getPaymentProcessor()
    {
        return $this->container['payment_processor'];
    }

    /**
     * Sets payment_processor
     *
     * @param string|null $payment_processor The usptream payment processor for the payout.
     *
     * @return self
     */
    public function setPaymentProcessor($payment_processor)
    {
        if (is_null($payment_processor)) {
            throw new \InvalidArgumentException('non-nullable payment_processor cannot be null');
        }
        $allowedValues = $this->getPaymentProcessorAllowableValues();
        if (!in_array($payment_processor, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_processor', must be one of '%s'",
                    $payment_processor,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_processor'] = $payment_processor;

        return $this;
    }

    /**
     * Gets events
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPayoutEvent[]|null
     */
    public function getEvents()
    {
        return $this->container['events'];
    }

    /**
     * Sets events
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPayoutEvent[]|null $events The activity associated with the payout.
     *
     * @return self
     */
    public function setEvents($events)
    {
        if (is_null($events)) {
            array_push($this->openAPINullablesSetToNull, 'events');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('events', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['events'] = $events;

        return $this;
    }

    /**
     * Gets rule
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsRuleMinimal|null
     */
    public function getRule()
    {
        return $this->container['rule'];
    }

    /**
     * Sets rule
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsRuleMinimal|null $rule rule
     *
     * @return self
     */
    public function setRule($rule)
    {
        if (is_null($rule)) {
            throw new \InvalidArgumentException('non-nullable rule cannot be null');
        }
        $this->container['rule'] = $rule;

        return $this;
    }

    /**
     * Gets payment_rail
     *
     * @return string|null
     */
    public function getPaymentRail()
    {
        return $this->container['payment_rail'];
    }

    /**
     * Sets payment_rail
     *
     * @param string|null $payment_rail Optional field to indicate the payment rail to use for the payout. Currrently only  supports choosing between SEPA-CT and SEPA-INST for EUR payments. If not set, for a EUR  payment, the default behaviour is to attempt SEPA-INST and fallback to SEPA-CT if rejected.
     *
     * @return self
     */
    public function setPaymentRail($payment_rail)
    {
        if (is_null($payment_rail)) {
            throw new \InvalidArgumentException('non-nullable payment_rail cannot be null');
        }
        $allowedValues = $this->getPaymentRailAllowableValues();
        if (!in_array($payment_rail, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_rail', must be one of '%s'",
                    $payment_rail,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_rail'] = $payment_rail;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}



<?php
/**
 * NoFrixionMoneyMoovModelsPaymentRequestPaymentAttempt
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NoFrixion MoneyMoov API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Nofrixion\Client\Model;

use \ArrayAccess;
use \Nofrixion\Client\ObjectSerializer;

/**
 * NoFrixionMoneyMoovModelsPaymentRequestPaymentAttempt Class Doc Comment
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class NoFrixionMoneyMoovModelsPaymentRequestPaymentAttempt implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'NoFrixion.MoneyMoov.Models.PaymentRequestPaymentAttempt';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'attempt_key' => 'string',
        'payment_request_id' => 'string',
        'initiated_at' => '\DateTime',
        'authorised_at' => '\DateTime',
        'card_authorised_at' => '\DateTime',
        'card_payer_authentication_setup_failed_at' => '\DateTime',
        'card_authorise_failed_at' => '\DateTime',
        'settled_at' => '\DateTime',
        'settle_failed_at' => '\DateTime',
        'payment_method' => 'string',
        'attempted_amount' => 'float',
        'authorised_amount' => 'float',
        'card_authorised_amount' => 'float',
        'settled_amount' => 'float',
        'refund_attempts' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestRefundAttempt[]',
        'capture_attempts' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestCaptureAttempt[]',
        'currency' => 'string',
        'payment_processor' => 'string',
        'wallet_name' => 'string',
        'institution_id' => 'string',
        'institution_name' => 'string',
        'tokenised_card_id' => 'string',
        'reconciled_transaction_id' => 'string',
        'pisp_authorisation_failed_at' => '\DateTime',
        'status' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'attempt_key' => null,
        'payment_request_id' => 'uuid',
        'initiated_at' => 'date-time',
        'authorised_at' => 'date-time',
        'card_authorised_at' => 'date-time',
        'card_payer_authentication_setup_failed_at' => 'date-time',
        'card_authorise_failed_at' => 'date-time',
        'settled_at' => 'date-time',
        'settle_failed_at' => 'date-time',
        'payment_method' => null,
        'attempted_amount' => 'double',
        'authorised_amount' => 'double',
        'card_authorised_amount' => 'double',
        'settled_amount' => 'double',
        'refund_attempts' => null,
        'capture_attempts' => null,
        'currency' => null,
        'payment_processor' => null,
        'wallet_name' => null,
        'institution_id' => null,
        'institution_name' => null,
        'tokenised_card_id' => null,
        'reconciled_transaction_id' => 'uuid',
        'pisp_authorisation_failed_at' => 'date-time',
        'status' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'attempt_key' => true,
        'payment_request_id' => false,
        'initiated_at' => false,
        'authorised_at' => true,
        'card_authorised_at' => true,
        'card_payer_authentication_setup_failed_at' => true,
        'card_authorise_failed_at' => true,
        'settled_at' => true,
        'settle_failed_at' => true,
        'payment_method' => false,
        'attempted_amount' => false,
        'authorised_amount' => false,
        'card_authorised_amount' => false,
        'settled_amount' => false,
        'refund_attempts' => true,
        'capture_attempts' => true,
        'currency' => false,
        'payment_processor' => false,
        'wallet_name' => true,
        'institution_id' => true,
        'institution_name' => true,
        'tokenised_card_id' => true,
        'reconciled_transaction_id' => true,
        'pisp_authorisation_failed_at' => true,
        'status' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'attempt_key' => 'attemptKey',
        'payment_request_id' => 'paymentRequestID',
        'initiated_at' => 'initiatedAt',
        'authorised_at' => 'authorisedAt',
        'card_authorised_at' => 'cardAuthorisedAt',
        'card_payer_authentication_setup_failed_at' => 'cardPayerAuthenticationSetupFailedAt',
        'card_authorise_failed_at' => 'cardAuthoriseFailedAt',
        'settled_at' => 'settledAt',
        'settle_failed_at' => 'settleFailedAt',
        'payment_method' => 'paymentMethod',
        'attempted_amount' => 'attemptedAmount',
        'authorised_amount' => 'authorisedAmount',
        'card_authorised_amount' => 'cardAuthorisedAmount',
        'settled_amount' => 'settledAmount',
        'refund_attempts' => 'refundAttempts',
        'capture_attempts' => 'captureAttempts',
        'currency' => 'currency',
        'payment_processor' => 'paymentProcessor',
        'wallet_name' => 'walletName',
        'institution_id' => 'institutionID',
        'institution_name' => 'institutionName',
        'tokenised_card_id' => 'tokenisedCardID',
        'reconciled_transaction_id' => 'reconciledTransactionID',
        'pisp_authorisation_failed_at' => 'pispAuthorisationFailedAt',
        'status' => 'status'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'attempt_key' => 'setAttemptKey',
        'payment_request_id' => 'setPaymentRequestId',
        'initiated_at' => 'setInitiatedAt',
        'authorised_at' => 'setAuthorisedAt',
        'card_authorised_at' => 'setCardAuthorisedAt',
        'card_payer_authentication_setup_failed_at' => 'setCardPayerAuthenticationSetupFailedAt',
        'card_authorise_failed_at' => 'setCardAuthoriseFailedAt',
        'settled_at' => 'setSettledAt',
        'settle_failed_at' => 'setSettleFailedAt',
        'payment_method' => 'setPaymentMethod',
        'attempted_amount' => 'setAttemptedAmount',
        'authorised_amount' => 'setAuthorisedAmount',
        'card_authorised_amount' => 'setCardAuthorisedAmount',
        'settled_amount' => 'setSettledAmount',
        'refund_attempts' => 'setRefundAttempts',
        'capture_attempts' => 'setCaptureAttempts',
        'currency' => 'setCurrency',
        'payment_processor' => 'setPaymentProcessor',
        'wallet_name' => 'setWalletName',
        'institution_id' => 'setInstitutionId',
        'institution_name' => 'setInstitutionName',
        'tokenised_card_id' => 'setTokenisedCardId',
        'reconciled_transaction_id' => 'setReconciledTransactionId',
        'pisp_authorisation_failed_at' => 'setPispAuthorisationFailedAt',
        'status' => 'setStatus'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'attempt_key' => 'getAttemptKey',
        'payment_request_id' => 'getPaymentRequestId',
        'initiated_at' => 'getInitiatedAt',
        'authorised_at' => 'getAuthorisedAt',
        'card_authorised_at' => 'getCardAuthorisedAt',
        'card_payer_authentication_setup_failed_at' => 'getCardPayerAuthenticationSetupFailedAt',
        'card_authorise_failed_at' => 'getCardAuthoriseFailedAt',
        'settled_at' => 'getSettledAt',
        'settle_failed_at' => 'getSettleFailedAt',
        'payment_method' => 'getPaymentMethod',
        'attempted_amount' => 'getAttemptedAmount',
        'authorised_amount' => 'getAuthorisedAmount',
        'card_authorised_amount' => 'getCardAuthorisedAmount',
        'settled_amount' => 'getSettledAmount',
        'refund_attempts' => 'getRefundAttempts',
        'capture_attempts' => 'getCaptureAttempts',
        'currency' => 'getCurrency',
        'payment_processor' => 'getPaymentProcessor',
        'wallet_name' => 'getWalletName',
        'institution_id' => 'getInstitutionId',
        'institution_name' => 'getInstitutionName',
        'tokenised_card_id' => 'getTokenisedCardId',
        'reconciled_transaction_id' => 'getReconciledTransactionId',
        'pisp_authorisation_failed_at' => 'getPispAuthorisationFailedAt',
        'status' => 'getStatus'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const PAYMENT_METHOD_NONE = 'None';
    public const PAYMENT_METHOD_CARD = 'card';
    public const PAYMENT_METHOD_PISP = 'pisp';
    public const PAYMENT_METHOD_LIGHTNING = 'lightning';
    public const PAYMENT_METHOD_CARDTOKEN = 'cardtoken';
    public const PAYMENT_METHOD_APPLE_PAY = 'applePay';
    public const PAYMENT_METHOD_GOOGLE_PAY = 'googlePay';
    public const PAYMENT_METHOD_DIRECT_DEBIT = 'directDebit';
    public const CURRENCY_NONE = 'NONE';
    public const CURRENCY_GBP = 'GBP';
    public const CURRENCY_EUR = 'EUR';
    public const CURRENCY_BTC = 'BTC';
    public const PAYMENT_PROCESSOR_NONE = 'None';
    public const PAYMENT_PROCESSOR_CYBER_SOURCE = 'CyberSource';
    public const PAYMENT_PROCESSOR_CHECKOUT = 'Checkout';
    public const PAYMENT_PROCESSOR_STRIPE = 'Stripe';
    public const PAYMENT_PROCESSOR_MODULR = 'Modulr';
    public const PAYMENT_PROCESSOR_PLAID = 'Plaid';
    public const PAYMENT_PROCESSOR_YAPILY = 'Yapily';
    public const PAYMENT_PROCESSOR_NOFRIXION = 'Nofrixion';
    public const PAYMENT_PROCESSOR_BITCOIN = 'Bitcoin';
    public const PAYMENT_PROCESSOR_BITCOIN_TESTNET = 'BitcoinTestnet';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE = 'BankingCircle';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE_AGENCY = 'BankingCircleAgency';
    public const PAYMENT_PROCESSOR_SIMULATOR = 'Simulator';
    public const PAYMENT_PROCESSOR_LIGHTNING = 'Lightning';
    public const PAYMENT_PROCESSOR_LIGHTNING_TESTNET = 'LightningTestnet';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE_DIRECT_DEBIT = 'BankingCircleDirectDebit';
    public const PAYMENT_PROCESSOR_TRIBE = 'Tribe';
    public const WALLET_NAME_APPLE_PAY = 'ApplePay';
    public const WALLET_NAME_GOOGLE_PAY = 'GooglePay';
    public const STATUS_NONE = 'None';
    public const STATUS_FULLY_PAID = 'FullyPaid';
    public const STATUS_PARTIALLY_PAID = 'PartiallyPaid';
    public const STATUS_OVER_PAID = 'OverPaid';
    public const STATUS_VOIDED = 'Voided';
    public const STATUS_AUTHORIZED = 'Authorized';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentMethodAllowableValues()
    {
        return [
            self::PAYMENT_METHOD_NONE,
            self::PAYMENT_METHOD_CARD,
            self::PAYMENT_METHOD_PISP,
            self::PAYMENT_METHOD_LIGHTNING,
            self::PAYMENT_METHOD_CARDTOKEN,
            self::PAYMENT_METHOD_APPLE_PAY,
            self::PAYMENT_METHOD_GOOGLE_PAY,
            self::PAYMENT_METHOD_DIRECT_DEBIT,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCurrencyAllowableValues()
    {
        return [
            self::CURRENCY_NONE,
            self::CURRENCY_GBP,
            self::CURRENCY_EUR,
            self::CURRENCY_BTC,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentProcessorAllowableValues()
    {
        return [
            self::PAYMENT_PROCESSOR_NONE,
            self::PAYMENT_PROCESSOR_CYBER_SOURCE,
            self::PAYMENT_PROCESSOR_CHECKOUT,
            self::PAYMENT_PROCESSOR_STRIPE,
            self::PAYMENT_PROCESSOR_MODULR,
            self::PAYMENT_PROCESSOR_PLAID,
            self::PAYMENT_PROCESSOR_YAPILY,
            self::PAYMENT_PROCESSOR_NOFRIXION,
            self::PAYMENT_PROCESSOR_BITCOIN,
            self::PAYMENT_PROCESSOR_BITCOIN_TESTNET,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE_AGENCY,
            self::PAYMENT_PROCESSOR_SIMULATOR,
            self::PAYMENT_PROCESSOR_LIGHTNING,
            self::PAYMENT_PROCESSOR_LIGHTNING_TESTNET,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE_DIRECT_DEBIT,
            self::PAYMENT_PROCESSOR_TRIBE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getWalletNameAllowableValues()
    {
        return [
            self::WALLET_NAME_APPLE_PAY,
            self::WALLET_NAME_GOOGLE_PAY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_NONE,
            self::STATUS_FULLY_PAID,
            self::STATUS_PARTIALLY_PAID,
            self::STATUS_OVER_PAID,
            self::STATUS_VOIDED,
            self::STATUS_AUTHORIZED,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('attempt_key', $data ?? [], null);
        $this->setIfExists('payment_request_id', $data ?? [], null);
        $this->setIfExists('initiated_at', $data ?? [], null);
        $this->setIfExists('authorised_at', $data ?? [], null);
        $this->setIfExists('card_authorised_at', $data ?? [], null);
        $this->setIfExists('card_payer_authentication_setup_failed_at', $data ?? [], null);
        $this->setIfExists('card_authorise_failed_at', $data ?? [], null);
        $this->setIfExists('settled_at', $data ?? [], null);
        $this->setIfExists('settle_failed_at', $data ?? [], null);
        $this->setIfExists('payment_method', $data ?? [], null);
        $this->setIfExists('attempted_amount', $data ?? [], null);
        $this->setIfExists('authorised_amount', $data ?? [], null);
        $this->setIfExists('card_authorised_amount', $data ?? [], null);
        $this->setIfExists('settled_amount', $data ?? [], null);
        $this->setIfExists('refund_attempts', $data ?? [], null);
        $this->setIfExists('capture_attempts', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('payment_processor', $data ?? [], null);
        $this->setIfExists('wallet_name', $data ?? [], null);
        $this->setIfExists('institution_id', $data ?? [], null);
        $this->setIfExists('institution_name', $data ?? [], null);
        $this->setIfExists('tokenised_card_id', $data ?? [], null);
        $this->setIfExists('reconciled_transaction_id', $data ?? [], null);
        $this->setIfExists('pisp_authorisation_failed_at', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getPaymentMethodAllowableValues();
        if (!is_null($this->container['payment_method']) && !in_array($this->container['payment_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_method', must be one of '%s'",
                $this->container['payment_method'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCurrencyAllowableValues();
        if (!is_null($this->container['currency']) && !in_array($this->container['currency'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'currency', must be one of '%s'",
                $this->container['currency'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPaymentProcessorAllowableValues();
        if (!is_null($this->container['payment_processor']) && !in_array($this->container['payment_processor'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_processor', must be one of '%s'",
                $this->container['payment_processor'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getWalletNameAllowableValues();
        if (!is_null($this->container['wallet_name']) && !in_array($this->container['wallet_name'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'wallet_name', must be one of '%s'",
                $this->container['wallet_name'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets attempt_key
     *
     * @return string|null
     */
    public function getAttemptKey()
    {
        return $this->container['attempt_key'];
    }

    /**
     * Sets attempt_key
     *
     * @param string|null $attempt_key For pay by bank attempts this is the ID that gets set on all the events (initiate,  callback, webhook and settlement) for the same attempt. For cards and lightning different  fields are used to group payment request events.
     *
     * @return self
     */
    public function setAttemptKey($attempt_key)
    {
        if (is_null($attempt_key)) {
            array_push($this->openAPINullablesSetToNull, 'attempt_key');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('attempt_key', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['attempt_key'] = $attempt_key;

        return $this;
    }

    /**
     * Gets payment_request_id
     *
     * @return string|null
     */
    public function getPaymentRequestId()
    {
        return $this->container['payment_request_id'];
    }

    /**
     * Sets payment_request_id
     *
     * @param string|null $payment_request_id The ID of the payment request the result is for.
     *
     * @return self
     */
    public function setPaymentRequestId($payment_request_id)
    {
        if (is_null($payment_request_id)) {
            throw new \InvalidArgumentException('non-nullable payment_request_id cannot be null');
        }
        $this->container['payment_request_id'] = $payment_request_id;

        return $this;
    }

    /**
     * Gets initiated_at
     *
     * @return \DateTime|null
     */
    public function getInitiatedAt()
    {
        return $this->container['initiated_at'];
    }

    /**
     * Sets initiated_at
     *
     * @param \DateTime|null $initiated_at Timestamp the payment was initiated at.
     *
     * @return self
     */
    public function setInitiatedAt($initiated_at)
    {
        if (is_null($initiated_at)) {
            throw new \InvalidArgumentException('non-nullable initiated_at cannot be null');
        }
        $this->container['initiated_at'] = $initiated_at;

        return $this;
    }

    /**
     * Gets authorised_at
     *
     * @return \DateTime|null
     */
    public function getAuthorisedAt()
    {
        return $this->container['authorised_at'];
    }

    /**
     * Sets authorised_at
     *
     * @param \DateTime|null $authorised_at If the attempt was authorised this is the timestamp it occurred at.
     *
     * @return self
     */
    public function setAuthorisedAt($authorised_at)
    {
        if (is_null($authorised_at)) {
            array_push($this->openAPINullablesSetToNull, 'authorised_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('authorised_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['authorised_at'] = $authorised_at;

        return $this;
    }

    /**
     * Gets card_authorised_at
     *
     * @return \DateTime|null
     */
    public function getCardAuthorisedAt()
    {
        return $this->container['card_authorised_at'];
    }

    /**
     * Sets card_authorised_at
     *
     * @param \DateTime|null $card_authorised_at If the card payment attempt was authorised this is the timestamp it occurred at.
     *
     * @return self
     */
    public function setCardAuthorisedAt($card_authorised_at)
    {
        if (is_null($card_authorised_at)) {
            array_push($this->openAPINullablesSetToNull, 'card_authorised_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('card_authorised_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['card_authorised_at'] = $card_authorised_at;

        return $this;
    }

    /**
     * Gets card_payer_authentication_setup_failed_at
     *
     * @return \DateTime|null
     */
    public function getCardPayerAuthenticationSetupFailedAt()
    {
        return $this->container['card_payer_authentication_setup_failed_at'];
    }

    /**
     * Sets card_payer_authentication_setup_failed_at
     *
     * @param \DateTime|null $card_payer_authentication_setup_failed_at If the card payment attempt authorisation was not succesfully set up  this is the timestamp it occurred at.
     *
     * @return self
     */
    public function setCardPayerAuthenticationSetupFailedAt($card_payer_authentication_setup_failed_at)
    {
        if (is_null($card_payer_authentication_setup_failed_at)) {
            array_push($this->openAPINullablesSetToNull, 'card_payer_authentication_setup_failed_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('card_payer_authentication_setup_failed_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['card_payer_authentication_setup_failed_at'] = $card_payer_authentication_setup_failed_at;

        return $this;
    }

    /**
     * Gets card_authorise_failed_at
     *
     * @return \DateTime|null
     */
    public function getCardAuthoriseFailedAt()
    {
        return $this->container['card_authorise_failed_at'];
    }

    /**
     * Sets card_authorise_failed_at
     *
     * @param \DateTime|null $card_authorise_failed_at If the card payment attempt was not succesfully authorised this is the timestamp  it occurred at.
     *
     * @return self
     */
    public function setCardAuthoriseFailedAt($card_authorise_failed_at)
    {
        if (is_null($card_authorise_failed_at)) {
            array_push($this->openAPINullablesSetToNull, 'card_authorise_failed_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('card_authorise_failed_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['card_authorise_failed_at'] = $card_authorise_failed_at;

        return $this;
    }

    /**
     * Gets settled_at
     *
     * @return \DateTime|null
     */
    public function getSettledAt()
    {
        return $this->container['settled_at'];
    }

    /**
     * Sets settled_at
     *
     * @param \DateTime|null $settled_at If the PISP attempt was settled this is the timestamp it occurred at.
     *
     * @return self
     */
    public function setSettledAt($settled_at)
    {
        if (is_null($settled_at)) {
            array_push($this->openAPINullablesSetToNull, 'settled_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('settled_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['settled_at'] = $settled_at;

        return $this;
    }

    /**
     * Gets settle_failed_at
     *
     * @return \DateTime|null
     */
    public function getSettleFailedAt()
    {
        return $this->container['settle_failed_at'];
    }

    /**
     * Sets settle_failed_at
     *
     * @param \DateTime|null $settle_failed_at If the PISP attempt failed to settled after the expected settlement time this  is the timestamp the failure was recorded at.
     *
     * @return self
     */
    public function setSettleFailedAt($settle_failed_at)
    {
        if (is_null($settle_failed_at)) {
            array_push($this->openAPINullablesSetToNull, 'settle_failed_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('settle_failed_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['settle_failed_at'] = $settle_failed_at;

        return $this;
    }

    /**
     * Gets payment_method
     *
     * @return string|null
     */
    public function getPaymentMethod()
    {
        return $this->container['payment_method'];
    }

    /**
     * Sets payment_method
     *
     * @param string|null $payment_method The payment type for the received money.
     *
     * @return self
     */
    public function setPaymentMethod($payment_method)
    {
        if (is_null($payment_method)) {
            throw new \InvalidArgumentException('non-nullable payment_method cannot be null');
        }
        $allowedValues = $this->getPaymentMethodAllowableValues();
        if (!in_array($payment_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_method', must be one of '%s'",
                    $payment_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_method'] = $payment_method;

        return $this;
    }

    /**
     * Gets attempted_amount
     *
     * @return float|null
     */
    public function getAttemptedAmount()
    {
        return $this->container['attempted_amount'];
    }

    /**
     * Sets attempted_amount
     *
     * @param float|null $attempted_amount The payment amount attempted.
     *
     * @return self
     */
    public function setAttemptedAmount($attempted_amount)
    {
        if (is_null($attempted_amount)) {
            throw new \InvalidArgumentException('non-nullable attempted_amount cannot be null');
        }
        $this->container['attempted_amount'] = $attempted_amount;

        return $this;
    }

    /**
     * Gets authorised_amount
     *
     * @return float|null
     */
    public function getAuthorisedAmount()
    {
        return $this->container['authorised_amount'];
    }

    /**
     * Sets authorised_amount
     *
     * @param float|null $authorised_amount The payment amount that was authorised by the payer.
     *
     * @return self
     */
    public function setAuthorisedAmount($authorised_amount)
    {
        if (is_null($authorised_amount)) {
            throw new \InvalidArgumentException('non-nullable authorised_amount cannot be null');
        }
        $this->container['authorised_amount'] = $authorised_amount;

        return $this;
    }

    /**
     * Gets card_authorised_amount
     *
     * @return float|null
     */
    public function getCardAuthorisedAmount()
    {
        return $this->container['card_authorised_amount'];
    }

    /**
     * Sets card_authorised_amount
     *
     * @param float|null $card_authorised_amount The card payment amount that was authorised by the payer.
     *
     * @return self
     */
    public function setCardAuthorisedAmount($card_authorised_amount)
    {
        if (is_null($card_authorised_amount)) {
            throw new \InvalidArgumentException('non-nullable card_authorised_amount cannot be null');
        }
        $this->container['card_authorised_amount'] = $card_authorised_amount;

        return $this;
    }

    /**
     * Gets settled_amount
     *
     * @return float|null
     */
    public function getSettledAmount()
    {
        return $this->container['settled_amount'];
    }

    /**
     * Sets settled_amount
     *
     * @param float|null $settled_amount The funds that were received from the payer.
     *
     * @return self
     */
    public function setSettledAmount($settled_amount)
    {
        if (is_null($settled_amount)) {
            throw new \InvalidArgumentException('non-nullable settled_amount cannot be null');
        }
        $this->container['settled_amount'] = $settled_amount;

        return $this;
    }

    /**
     * Gets refund_attempts
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestRefundAttempt[]|null
     */
    public function getRefundAttempts()
    {
        return $this->container['refund_attempts'];
    }

    /**
     * Sets refund_attempts
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestRefundAttempt[]|null $refund_attempts The refund attempts associated with this payment attempt.
     *
     * @return self
     */
    public function setRefundAttempts($refund_attempts)
    {
        if (is_null($refund_attempts)) {
            array_push($this->openAPINullablesSetToNull, 'refund_attempts');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('refund_attempts', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['refund_attempts'] = $refund_attempts;

        return $this;
    }

    /**
     * Gets capture_attempts
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestCaptureAttempt[]|null
     */
    public function getCaptureAttempts()
    {
        return $this->container['capture_attempts'];
    }

    /**
     * Sets capture_attempts
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestCaptureAttempt[]|null $capture_attempts The card capture attempts associated with this payment attempt.
     *
     * @return self
     */
    public function setCaptureAttempts($capture_attempts)
    {
        if (is_null($capture_attempts)) {
            array_push($this->openAPINullablesSetToNull, 'capture_attempts');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('capture_attempts', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['capture_attempts'] = $capture_attempts;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency The authorised payment currency.
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        $allowedValues = $this->getCurrencyAllowableValues();
        if (!in_array($currency, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'currency', must be one of '%s'",
                    $currency,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets payment_processor
     *
     * @return string|null
     */
    public function getPaymentProcessor()
    {
        return $this->container['payment_processor'];
    }

    /**
     * Sets payment_processor
     *
     * @param string|null $payment_processor The card processor that was used for the payment event.
     *
     * @return self
     */
    public function setPaymentProcessor($payment_processor)
    {
        if (is_null($payment_processor)) {
            throw new \InvalidArgumentException('non-nullable payment_processor cannot be null');
        }
        $allowedValues = $this->getPaymentProcessorAllowableValues();
        if (!in_array($payment_processor, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_processor', must be one of '%s'",
                    $payment_processor,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_processor'] = $payment_processor;

        return $this;
    }

    /**
     * Gets wallet_name
     *
     * @return string|null
     */
    public function getWalletName()
    {
        return $this->container['wallet_name'];
    }

    /**
     * Sets wallet_name
     *
     * @param string|null $wallet_name wallet_name
     *
     * @return self
     */
    public function setWalletName($wallet_name)
    {
        if (is_null($wallet_name)) {
            array_push($this->openAPINullablesSetToNull, 'wallet_name');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('wallet_name', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getWalletNameAllowableValues();
        if (!is_null($wallet_name) && !in_array($wallet_name, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'wallet_name', must be one of '%s'",
                    $wallet_name,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['wallet_name'] = $wallet_name;

        return $this;
    }

    /**
     * Gets institution_id
     *
     * @return string|null
     */
    public function getInstitutionId()
    {
        return $this->container['institution_id'];
    }

    /**
     * Sets institution_id
     *
     * @param string|null $institution_id Where available this is the ID of the institution used by the payer. For example in PIS attempts  this will be the ID of the bank the payer used for the attempt.
     *
     * @return self
     */
    public function setInstitutionId($institution_id)
    {
        if (is_null($institution_id)) {
            array_push($this->openAPINullablesSetToNull, 'institution_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('institution_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['institution_id'] = $institution_id;

        return $this;
    }

    /**
     * Gets institution_name
     *
     * @return string|null
     */
    public function getInstitutionName()
    {
        return $this->container['institution_name'];
    }

    /**
     * Sets institution_name
     *
     * @param string|null $institution_name Where available this is the name of the institution used by the payer. For example,  in PIS attempts this will be the name of the bank the payer used for the attempt.
     *
     * @return self
     */
    public function setInstitutionName($institution_name)
    {
        if (is_null($institution_name)) {
            array_push($this->openAPINullablesSetToNull, 'institution_name');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('institution_name', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['institution_name'] = $institution_name;

        return $this;
    }

    /**
     * Gets tokenised_card_id
     *
     * @return string|null
     */
    public function getTokenisedCardId()
    {
        return $this->container['tokenised_card_id'];
    }

    /**
     * Sets tokenised_card_id
     *
     * @param string|null $tokenised_card_id For card payments the merchant can request a reusable token for this payer and  use it to submit subsequent merchant initiated payments.
     *
     * @return self
     */
    public function setTokenisedCardId($tokenised_card_id)
    {
        if (is_null($tokenised_card_id)) {
            array_push($this->openAPINullablesSetToNull, 'tokenised_card_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tokenised_card_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tokenised_card_id'] = $tokenised_card_id;

        return $this;
    }

    /**
     * Gets reconciled_transaction_id
     *
     * @return string|null
     */
    public function getReconciledTransactionId()
    {
        return $this->container['reconciled_transaction_id'];
    }

    /**
     * Sets reconciled_transaction_id
     *
     * @param string|null $reconciled_transaction_id When the payment attempt is settled (only relevant for non-card payments) this is the payin transaction that  the payment request event was reconciled with.
     *
     * @return self
     */
    public function setReconciledTransactionId($reconciled_transaction_id)
    {
        if (is_null($reconciled_transaction_id)) {
            array_push($this->openAPINullablesSetToNull, 'reconciled_transaction_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('reconciled_transaction_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['reconciled_transaction_id'] = $reconciled_transaction_id;

        return $this;
    }

    /**
     * Gets pisp_authorisation_failed_at
     *
     * @return \DateTime|null
     */
    public function getPispAuthorisationFailedAt()
    {
        return $this->container['pisp_authorisation_failed_at'];
    }

    /**
     * Sets pisp_authorisation_failed_at
     *
     * @param \DateTime|null $pisp_authorisation_failed_at Timestamp for PSIP bank authorisation error or failure.
     *
     * @return self
     */
    public function setPispAuthorisationFailedAt($pisp_authorisation_failed_at)
    {
        if (is_null($pisp_authorisation_failed_at)) {
            array_push($this->openAPINullablesSetToNull, 'pisp_authorisation_failed_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('pisp_authorisation_failed_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['pisp_authorisation_failed_at'] = $pisp_authorisation_failed_at;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status status
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}



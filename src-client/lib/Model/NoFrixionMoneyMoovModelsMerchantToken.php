<?php
/**
 * NoFrixionMoneyMoovModelsMerchantToken
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NoFrixion MoneyMoov API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Nofrixion\Client\Model;

use \ArrayAccess;
use \Nofrixion\Client\ObjectSerializer;

/**
 * NoFrixionMoneyMoovModelsMerchantToken Class Doc Comment
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class NoFrixionMoneyMoovModelsMerchantToken implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'NoFrixion.MoneyMoov.Models.MerchantToken';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'string',
        'merchant_id' => 'string',
        'description' => 'string',
        'permissions' => 'string',
        'inserted' => '\DateTime',
        'last_updated' => '\DateTime',
        'token' => 'string',
        'is_enabled' => 'bool',
        'shared_secret_algorithm' => 'string',
        'shared_secret_base64' => 'string',
        'request_signature_version' => 'int',
        'expires_at' => '\DateTime'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => 'uuid',
        'merchant_id' => 'uuid',
        'description' => null,
        'permissions' => null,
        'inserted' => 'date-time',
        'last_updated' => 'date-time',
        'token' => null,
        'is_enabled' => null,
        'shared_secret_algorithm' => null,
        'shared_secret_base64' => null,
        'request_signature_version' => 'int32',
        'expires_at' => 'date-time'
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
        'merchant_id' => false,
        'description' => true,
        'permissions' => false,
        'inserted' => false,
        'last_updated' => false,
        'token' => true,
        'is_enabled' => false,
        'shared_secret_algorithm' => false,
        'shared_secret_base64' => true,
        'request_signature_version' => false,
        'expires_at' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'merchant_id' => 'merchantID',
        'description' => 'description',
        'permissions' => 'permissions',
        'inserted' => 'inserted',
        'last_updated' => 'lastUpdated',
        'token' => 'token',
        'is_enabled' => 'isEnabled',
        'shared_secret_algorithm' => 'sharedSecretAlgorithm',
        'shared_secret_base64' => 'sharedSecretBase64',
        'request_signature_version' => 'requestSignatureVersion',
        'expires_at' => 'expiresAt'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'merchant_id' => 'setMerchantId',
        'description' => 'setDescription',
        'permissions' => 'setPermissions',
        'inserted' => 'setInserted',
        'last_updated' => 'setLastUpdated',
        'token' => 'setToken',
        'is_enabled' => 'setIsEnabled',
        'shared_secret_algorithm' => 'setSharedSecretAlgorithm',
        'shared_secret_base64' => 'setSharedSecretBase64',
        'request_signature_version' => 'setRequestSignatureVersion',
        'expires_at' => 'setExpiresAt'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'merchant_id' => 'getMerchantId',
        'description' => 'getDescription',
        'permissions' => 'getPermissions',
        'inserted' => 'getInserted',
        'last_updated' => 'getLastUpdated',
        'token' => 'getToken',
        'is_enabled' => 'getIsEnabled',
        'shared_secret_algorithm' => 'getSharedSecretAlgorithm',
        'shared_secret_base64' => 'getSharedSecretBase64',
        'request_signature_version' => 'getRequestSignatureVersion',
        'expires_at' => 'getExpiresAt'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const PERMISSIONS_DENY = 'Deny';
    public const PERMISSIONS_CREATE_PAYMENT_REQUEST = 'CreatePaymentRequest';
    public const PERMISSIONS_EDIT_PAYMENT_REQUEST = 'EditPaymentRequest';
    public const PERMISSIONS_DELETE_PAYMENT_REQUEST = 'DeletePaymentRequest';
    public const PERMISSIONS_CREATE_RULE = 'CreateRule';
    public const PERMISSIONS_EDIT_RULE = 'EditRule';
    public const PERMISSIONS_DELETE_RULE = 'DeleteRule';
    public const PERMISSIONS_CREATE_PAYOUT = 'CreatePayout';
    public const PERMISSIONS_EDIT_PAYOUT = 'EditPayout';
    public const PERMISSIONS_DELETE_PAYOUT = 'DeletePayout';
    public const PERMISSIONS_CREATE_REPORT = 'CreateReport';
    public const PERMISSIONS_EDIT_REPORT = 'EditReport';
    public const PERMISSIONS_DELETE_REPORT = 'DeleteReport';
    public const PERMISSIONS_EXECUTE_REPORT = 'ExecuteReport';
    public const PERMISSIONS_CREATE_PAYMENT_ACCOUNT = 'CreatePaymentAccount';
    public const PERMISSIONS_EDIT_PAYMENT_ACCOUNT = 'EditPaymentAccount';
    public const PERMISSIONS_TRUSTED_SUBMIT_PAYOUT = 'TrustedSubmitPayout';
    public const PERMISSIONS_OPEN_BANKING_ACCOUNT_INFORMATION = 'OpenBankingAccountInformation';
    public const PERMISSIONS_CREATE_DIRECT_DEBIT_MANDATE = 'CreateDirectDebitMandate';
    public const PERMISSIONS_SUBMIT_DIRECT_DEBIT_PAYMENT = 'SubmitDirectDebitPayment';
    public const PERMISSIONS_VIEW_TRANSACTIONS = 'ViewTransactions';
    public const SHARED_SECRET_ALGORITHM_NONE = 'None';
    public const SHARED_SECRET_ALGORITHM_HMAC_SHA1 = 'HMAC_SHA1';
    public const SHARED_SECRET_ALGORITHM_HMAC_SHA256 = 'HMAC_SHA256';
    public const SHARED_SECRET_ALGORITHM_HMAC_SHA384 = 'HMAC_SHA384';
    public const SHARED_SECRET_ALGORITHM_HMAC_SHA512 = 'HMAC_SHA512';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPermissionsAllowableValues()
    {
        return [
            self::PERMISSIONS_DENY,
            self::PERMISSIONS_CREATE_PAYMENT_REQUEST,
            self::PERMISSIONS_EDIT_PAYMENT_REQUEST,
            self::PERMISSIONS_DELETE_PAYMENT_REQUEST,
            self::PERMISSIONS_CREATE_RULE,
            self::PERMISSIONS_EDIT_RULE,
            self::PERMISSIONS_DELETE_RULE,
            self::PERMISSIONS_CREATE_PAYOUT,
            self::PERMISSIONS_EDIT_PAYOUT,
            self::PERMISSIONS_DELETE_PAYOUT,
            self::PERMISSIONS_CREATE_REPORT,
            self::PERMISSIONS_EDIT_REPORT,
            self::PERMISSIONS_DELETE_REPORT,
            self::PERMISSIONS_EXECUTE_REPORT,
            self::PERMISSIONS_CREATE_PAYMENT_ACCOUNT,
            self::PERMISSIONS_EDIT_PAYMENT_ACCOUNT,
            self::PERMISSIONS_TRUSTED_SUBMIT_PAYOUT,
            self::PERMISSIONS_OPEN_BANKING_ACCOUNT_INFORMATION,
            self::PERMISSIONS_CREATE_DIRECT_DEBIT_MANDATE,
            self::PERMISSIONS_SUBMIT_DIRECT_DEBIT_PAYMENT,
            self::PERMISSIONS_VIEW_TRANSACTIONS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSharedSecretAlgorithmAllowableValues()
    {
        return [
            self::SHARED_SECRET_ALGORITHM_NONE,
            self::SHARED_SECRET_ALGORITHM_HMAC_SHA1,
            self::SHARED_SECRET_ALGORITHM_HMAC_SHA256,
            self::SHARED_SECRET_ALGORITHM_HMAC_SHA384,
            self::SHARED_SECRET_ALGORITHM_HMAC_SHA512,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('merchant_id', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('permissions', $data ?? [], null);
        $this->setIfExists('inserted', $data ?? [], null);
        $this->setIfExists('last_updated', $data ?? [], null);
        $this->setIfExists('token', $data ?? [], null);
        $this->setIfExists('is_enabled', $data ?? [], null);
        $this->setIfExists('shared_secret_algorithm', $data ?? [], null);
        $this->setIfExists('shared_secret_base64', $data ?? [], null);
        $this->setIfExists('request_signature_version', $data ?? [], null);
        $this->setIfExists('expires_at', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getPermissionsAllowableValues();
        if (!is_null($this->container['permissions']) && !in_array($this->container['permissions'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'permissions', must be one of '%s'",
                $this->container['permissions'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSharedSecretAlgorithmAllowableValues();
        if (!is_null($this->container['shared_secret_algorithm']) && !in_array($this->container['shared_secret_algorithm'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'shared_secret_algorithm', must be one of '%s'",
                $this->container['shared_secret_algorithm'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id id
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets merchant_id
     *
     * @return string|null
     */
    public function getMerchantId()
    {
        return $this->container['merchant_id'];
    }

    /**
     * Sets merchant_id
     *
     * @param string|null $merchant_id merchant_id
     *
     * @return self
     */
    public function setMerchantId($merchant_id)
    {
        if (is_null($merchant_id)) {
            throw new \InvalidArgumentException('non-nullable merchant_id cannot be null');
        }
        $this->container['merchant_id'] = $merchant_id;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description description
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            array_push($this->openAPINullablesSetToNull, 'description');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('description', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets permissions
     *
     * @return string|null
     */
    public function getPermissions()
    {
        return $this->container['permissions'];
    }

    /**
     * Sets permissions
     *
     * @param string|null $permissions permissions
     *
     * @return self
     */
    public function setPermissions($permissions)
    {
        if (is_null($permissions)) {
            throw new \InvalidArgumentException('non-nullable permissions cannot be null');
        }
        $allowedValues = $this->getPermissionsAllowableValues();
        if (!in_array($permissions, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'permissions', must be one of '%s'",
                    $permissions,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['permissions'] = $permissions;

        return $this;
    }

    /**
     * Gets inserted
     *
     * @return \DateTime|null
     */
    public function getInserted()
    {
        return $this->container['inserted'];
    }

    /**
     * Sets inserted
     *
     * @param \DateTime|null $inserted inserted
     *
     * @return self
     */
    public function setInserted($inserted)
    {
        if (is_null($inserted)) {
            throw new \InvalidArgumentException('non-nullable inserted cannot be null');
        }
        $this->container['inserted'] = $inserted;

        return $this;
    }

    /**
     * Gets last_updated
     *
     * @return \DateTime|null
     */
    public function getLastUpdated()
    {
        return $this->container['last_updated'];
    }

    /**
     * Sets last_updated
     *
     * @param \DateTime|null $last_updated last_updated
     *
     * @return self
     */
    public function setLastUpdated($last_updated)
    {
        if (is_null($last_updated)) {
            throw new \InvalidArgumentException('non-nullable last_updated cannot be null');
        }
        $this->container['last_updated'] = $last_updated;

        return $this;
    }

    /**
     * Gets token
     *
     * @return string|null
     */
    public function getToken()
    {
        return $this->container['token'];
    }

    /**
     * Sets token
     *
     * @param string|null $token The JWT merchant token. It will only be available when the merchant token is  initially created. The token is not stored by NoFrixion.
     *
     * @return self
     */
    public function setToken($token)
    {
        if (is_null($token)) {
            array_push($this->openAPINullablesSetToNull, 'token');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('token', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['token'] = $token;

        return $this;
    }

    /**
     * Gets is_enabled
     *
     * @return bool|null
     */
    public function getIsEnabled()
    {
        return $this->container['is_enabled'];
    }

    /**
     * Sets is_enabled
     *
     * @param bool|null $is_enabled If set to false the merchant token will not be accepted to authorise a request.
     *
     * @return self
     */
    public function setIsEnabled($is_enabled)
    {
        if (is_null($is_enabled)) {
            throw new \InvalidArgumentException('non-nullable is_enabled cannot be null');
        }
        $this->container['is_enabled'] = $is_enabled;

        return $this;
    }

    /**
     * Gets shared_secret_algorithm
     *
     * @return string|null
     */
    public function getSharedSecretAlgorithm()
    {
        return $this->container['shared_secret_algorithm'];
    }

    /**
     * Sets shared_secret_algorithm
     *
     * @param string|null $shared_secret_algorithm Optional shared secret algorithm to use for HMAC authentication.
     *
     * @return self
     */
    public function setSharedSecretAlgorithm($shared_secret_algorithm)
    {
        if (is_null($shared_secret_algorithm)) {
            throw new \InvalidArgumentException('non-nullable shared_secret_algorithm cannot be null');
        }
        $allowedValues = $this->getSharedSecretAlgorithmAllowableValues();
        if (!in_array($shared_secret_algorithm, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'shared_secret_algorithm', must be one of '%s'",
                    $shared_secret_algorithm,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['shared_secret_algorithm'] = $shared_secret_algorithm;

        return $this;
    }

    /**
     * Gets shared_secret_base64
     *
     * @return string|null
     */
    public function getSharedSecretBase64()
    {
        return $this->container['shared_secret_base64'];
    }

    /**
     * Sets shared_secret_base64
     *
     * @param string|null $shared_secret_base64 The base 64 encoded shared secret that is used for request authentication with an HMAC.  Note this property will ONLY be set when the token is initially created. It is not possible  to retrieve the secret afterwards. If it is lost a new token should be created.
     *
     * @return self
     */
    public function setSharedSecretBase64($shared_secret_base64)
    {
        if (is_null($shared_secret_base64)) {
            array_push($this->openAPINullablesSetToNull, 'shared_secret_base64');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('shared_secret_base64', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['shared_secret_base64'] = $shared_secret_base64;

        return $this;
    }

    /**
     * Gets request_signature_version
     *
     * @return int|null
     */
    public function getRequestSignatureVersion()
    {
        return $this->container['request_signature_version'];
    }

    /**
     * Sets request_signature_version
     *
     * @param int|null $request_signature_version Represent the version of the overall merchant token. This field is to allow the secret and public key mechanisms to  vary over time. For example if the HTTP header fields to include in the algorithms change this version will faciliatate  keeping track of which signature versions a particular merchant token is using.
     *
     * @return self
     */
    public function setRequestSignatureVersion($request_signature_version)
    {
        if (is_null($request_signature_version)) {
            throw new \InvalidArgumentException('non-nullable request_signature_version cannot be null');
        }
        $this->container['request_signature_version'] = $request_signature_version;

        return $this;
    }

    /**
     * Gets expires_at
     *
     * @return \DateTime|null
     */
    public function getExpiresAt()
    {
        return $this->container['expires_at'];
    }

    /**
     * Sets expires_at
     *
     * @param \DateTime|null $expires_at Optional. If set indicates the merchant token is not valid after the specified expiry date.
     *
     * @return self
     */
    public function setExpiresAt($expires_at)
    {
        if (is_null($expires_at)) {
            array_push($this->openAPINullablesSetToNull, 'expires_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('expires_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['expires_at'] = $expires_at;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}



<?php
/**
 * NoFrixionMoneyMoovModelsPaymentRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NoFrixion MoneyMoov API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.9.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Nofrixion\Client\Model;

use \ArrayAccess;
use \Nofrixion\Client\ObjectSerializer;

/**
 * NoFrixionMoneyMoovModelsPaymentRequest Class Doc Comment
 *
 * @category Class
 * @package  Nofrixion\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class NoFrixionMoneyMoovModelsPaymentRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'NoFrixion.MoneyMoov.Models.PaymentRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'string',
        'merchant_id' => 'string',
        'amount' => 'float',
        'currency' => 'string',
        'customer_id' => 'string',
        'order_id' => 'string',
        'payment_methods' => 'string[]',
        'description' => 'string',
        'pisp_account_id' => 'string',
        'base_origin_url' => 'string',
        'callback_url' => 'string',
        'failure_callback_url' => 'string',
        'success_web_hook_url' => 'string',
        'card_authorize_only' => 'bool',
        'card_create_token' => 'bool',
        'card_create_token_mode' => 'string',
        'ignore_address_verification' => 'bool',
        'card_ignore_cvn' => 'bool',
        'card_processor_merchant_id' => 'string',
        'payment_processor' => 'string',
        'lightning_invoice' => 'string',
        'status' => 'string',
        'hosted_pay_checkout_url' => 'string',
        'partial_payment_method' => 'string',
        'inserted' => '\DateTime',
        'inserted_sortable' => 'string',
        'last_updated' => '\DateTime',
        'use_hosted_payment_page' => 'bool',
        'customer_email_address' => 'string',
        'card_stripe_payment_intent_id' => 'string',
        'card_stripe_payment_intent_secret' => 'string',
        'addresses' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestAddress[]',
        'events' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestEvent[]',
        'tokenised_cards' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsCardCustomerToken[]',
        'transactions' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTransaction[]',
        'tags' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTag[]',
        'result' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestResult',
        'jwk' => 'string',
        'priority_bank_id' => 'string',
        'title' => 'string',
        'partial_payment_steps' => 'string',
        'payrun_id' => 'string',
        'shipping_address' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestAddress',
        'notification_email_addresses' => 'string',
        'payment_attempts' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestPaymentAttempt[]',
        'amount_received' => 'float',
        'amount_refunded' => 'float',
        'amount_pending' => 'float',
        'created_by_user' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsUser',
        'merchant_token_description' => 'string',
        'formatted_amount' => 'string',
        'lightning_invoice_expires_at' => '\DateTime',
        'destination_account' => '\Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentAccount',
        'customer_name' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => 'uuid',
        'merchant_id' => 'uuid',
        'amount' => 'double',
        'currency' => null,
        'customer_id' => null,
        'order_id' => null,
        'payment_methods' => null,
        'description' => null,
        'pisp_account_id' => 'uuid',
        'base_origin_url' => null,
        'callback_url' => null,
        'failure_callback_url' => null,
        'success_web_hook_url' => null,
        'card_authorize_only' => null,
        'card_create_token' => null,
        'card_create_token_mode' => null,
        'ignore_address_verification' => null,
        'card_ignore_cvn' => null,
        'card_processor_merchant_id' => null,
        'payment_processor' => null,
        'lightning_invoice' => null,
        'status' => null,
        'hosted_pay_checkout_url' => null,
        'partial_payment_method' => null,
        'inserted' => 'date-time',
        'inserted_sortable' => null,
        'last_updated' => 'date-time',
        'use_hosted_payment_page' => null,
        'customer_email_address' => 'email',
        'card_stripe_payment_intent_id' => null,
        'card_stripe_payment_intent_secret' => null,
        'addresses' => null,
        'events' => null,
        'tokenised_cards' => null,
        'transactions' => null,
        'tags' => null,
        'result' => null,
        'jwk' => null,
        'priority_bank_id' => 'uuid',
        'title' => null,
        'partial_payment_steps' => null,
        'payrun_id' => 'uuid',
        'shipping_address' => null,
        'notification_email_addresses' => null,
        'payment_attempts' => null,
        'amount_received' => 'double',
        'amount_refunded' => 'double',
        'amount_pending' => 'double',
        'created_by_user' => null,
        'merchant_token_description' => null,
        'formatted_amount' => null,
        'lightning_invoice_expires_at' => 'date-time',
        'destination_account' => null,
        'customer_name' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
        'merchant_id' => false,
        'amount' => false,
        'currency' => false,
        'customer_id' => true,
        'order_id' => true,
        'payment_methods' => true,
        'description' => true,
        'pisp_account_id' => true,
        'base_origin_url' => true,
        'callback_url' => true,
        'failure_callback_url' => true,
        'success_web_hook_url' => true,
        'card_authorize_only' => false,
        'card_create_token' => false,
        'card_create_token_mode' => false,
        'ignore_address_verification' => false,
        'card_ignore_cvn' => false,
        'card_processor_merchant_id' => true,
        'payment_processor' => false,
        'lightning_invoice' => true,
        'status' => false,
        'hosted_pay_checkout_url' => true,
        'partial_payment_method' => false,
        'inserted' => false,
        'inserted_sortable' => true,
        'last_updated' => false,
        'use_hosted_payment_page' => false,
        'customer_email_address' => true,
        'card_stripe_payment_intent_id' => true,
        'card_stripe_payment_intent_secret' => true,
        'addresses' => true,
        'events' => true,
        'tokenised_cards' => true,
        'transactions' => true,
        'tags' => true,
        'result' => false,
        'jwk' => true,
        'priority_bank_id' => true,
        'title' => true,
        'partial_payment_steps' => true,
        'payrun_id' => true,
        'shipping_address' => false,
        'notification_email_addresses' => true,
        'payment_attempts' => true,
        'amount_received' => false,
        'amount_refunded' => false,
        'amount_pending' => false,
        'created_by_user' => false,
        'merchant_token_description' => true,
        'formatted_amount' => true,
        'lightning_invoice_expires_at' => true,
        'destination_account' => false,
        'customer_name' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'merchant_id' => 'merchantID',
        'amount' => 'amount',
        'currency' => 'currency',
        'customer_id' => 'customerID',
        'order_id' => 'orderID',
        'payment_methods' => 'paymentMethods',
        'description' => 'description',
        'pisp_account_id' => 'pispAccountID',
        'base_origin_url' => 'baseOriginUrl',
        'callback_url' => 'callbackUrl',
        'failure_callback_url' => 'failureCallbackUrl',
        'success_web_hook_url' => 'successWebHookUrl',
        'card_authorize_only' => 'cardAuthorizeOnly',
        'card_create_token' => 'cardCreateToken',
        'card_create_token_mode' => 'cardCreateTokenMode',
        'ignore_address_verification' => 'ignoreAddressVerification',
        'card_ignore_cvn' => 'cardIgnoreCVN',
        'card_processor_merchant_id' => 'cardProcessorMerchantID',
        'payment_processor' => 'paymentProcessor',
        'lightning_invoice' => 'lightningInvoice',
        'status' => 'status',
        'hosted_pay_checkout_url' => 'hostedPayCheckoutUrl',
        'partial_payment_method' => 'partialPaymentMethod',
        'inserted' => 'inserted',
        'inserted_sortable' => 'insertedSortable',
        'last_updated' => 'lastUpdated',
        'use_hosted_payment_page' => 'useHostedPaymentPage',
        'customer_email_address' => 'customerEmailAddress',
        'card_stripe_payment_intent_id' => 'cardStripePaymentIntentID',
        'card_stripe_payment_intent_secret' => 'cardStripePaymentIntentSecret',
        'addresses' => 'addresses',
        'events' => 'events',
        'tokenised_cards' => 'tokenisedCards',
        'transactions' => 'transactions',
        'tags' => 'tags',
        'result' => 'result',
        'jwk' => 'jwk',
        'priority_bank_id' => 'priorityBankID',
        'title' => 'title',
        'partial_payment_steps' => 'partialPaymentSteps',
        'payrun_id' => 'payrunID',
        'shipping_address' => 'shippingAddress',
        'notification_email_addresses' => 'notificationEmailAddresses',
        'payment_attempts' => 'paymentAttempts',
        'amount_received' => 'amountReceived',
        'amount_refunded' => 'amountRefunded',
        'amount_pending' => 'amountPending',
        'created_by_user' => 'createdByUser',
        'merchant_token_description' => 'merchantTokenDescription',
        'formatted_amount' => 'formattedAmount',
        'lightning_invoice_expires_at' => 'lightningInvoiceExpiresAt',
        'destination_account' => 'destinationAccount',
        'customer_name' => 'customerName'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'merchant_id' => 'setMerchantId',
        'amount' => 'setAmount',
        'currency' => 'setCurrency',
        'customer_id' => 'setCustomerId',
        'order_id' => 'setOrderId',
        'payment_methods' => 'setPaymentMethods',
        'description' => 'setDescription',
        'pisp_account_id' => 'setPispAccountId',
        'base_origin_url' => 'setBaseOriginUrl',
        'callback_url' => 'setCallbackUrl',
        'failure_callback_url' => 'setFailureCallbackUrl',
        'success_web_hook_url' => 'setSuccessWebHookUrl',
        'card_authorize_only' => 'setCardAuthorizeOnly',
        'card_create_token' => 'setCardCreateToken',
        'card_create_token_mode' => 'setCardCreateTokenMode',
        'ignore_address_verification' => 'setIgnoreAddressVerification',
        'card_ignore_cvn' => 'setCardIgnoreCvn',
        'card_processor_merchant_id' => 'setCardProcessorMerchantId',
        'payment_processor' => 'setPaymentProcessor',
        'lightning_invoice' => 'setLightningInvoice',
        'status' => 'setStatus',
        'hosted_pay_checkout_url' => 'setHostedPayCheckoutUrl',
        'partial_payment_method' => 'setPartialPaymentMethod',
        'inserted' => 'setInserted',
        'inserted_sortable' => 'setInsertedSortable',
        'last_updated' => 'setLastUpdated',
        'use_hosted_payment_page' => 'setUseHostedPaymentPage',
        'customer_email_address' => 'setCustomerEmailAddress',
        'card_stripe_payment_intent_id' => 'setCardStripePaymentIntentId',
        'card_stripe_payment_intent_secret' => 'setCardStripePaymentIntentSecret',
        'addresses' => 'setAddresses',
        'events' => 'setEvents',
        'tokenised_cards' => 'setTokenisedCards',
        'transactions' => 'setTransactions',
        'tags' => 'setTags',
        'result' => 'setResult',
        'jwk' => 'setJwk',
        'priority_bank_id' => 'setPriorityBankId',
        'title' => 'setTitle',
        'partial_payment_steps' => 'setPartialPaymentSteps',
        'payrun_id' => 'setPayrunId',
        'shipping_address' => 'setShippingAddress',
        'notification_email_addresses' => 'setNotificationEmailAddresses',
        'payment_attempts' => 'setPaymentAttempts',
        'amount_received' => 'setAmountReceived',
        'amount_refunded' => 'setAmountRefunded',
        'amount_pending' => 'setAmountPending',
        'created_by_user' => 'setCreatedByUser',
        'merchant_token_description' => 'setMerchantTokenDescription',
        'formatted_amount' => 'setFormattedAmount',
        'lightning_invoice_expires_at' => 'setLightningInvoiceExpiresAt',
        'destination_account' => 'setDestinationAccount',
        'customer_name' => 'setCustomerName'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'merchant_id' => 'getMerchantId',
        'amount' => 'getAmount',
        'currency' => 'getCurrency',
        'customer_id' => 'getCustomerId',
        'order_id' => 'getOrderId',
        'payment_methods' => 'getPaymentMethods',
        'description' => 'getDescription',
        'pisp_account_id' => 'getPispAccountId',
        'base_origin_url' => 'getBaseOriginUrl',
        'callback_url' => 'getCallbackUrl',
        'failure_callback_url' => 'getFailureCallbackUrl',
        'success_web_hook_url' => 'getSuccessWebHookUrl',
        'card_authorize_only' => 'getCardAuthorizeOnly',
        'card_create_token' => 'getCardCreateToken',
        'card_create_token_mode' => 'getCardCreateTokenMode',
        'ignore_address_verification' => 'getIgnoreAddressVerification',
        'card_ignore_cvn' => 'getCardIgnoreCvn',
        'card_processor_merchant_id' => 'getCardProcessorMerchantId',
        'payment_processor' => 'getPaymentProcessor',
        'lightning_invoice' => 'getLightningInvoice',
        'status' => 'getStatus',
        'hosted_pay_checkout_url' => 'getHostedPayCheckoutUrl',
        'partial_payment_method' => 'getPartialPaymentMethod',
        'inserted' => 'getInserted',
        'inserted_sortable' => 'getInsertedSortable',
        'last_updated' => 'getLastUpdated',
        'use_hosted_payment_page' => 'getUseHostedPaymentPage',
        'customer_email_address' => 'getCustomerEmailAddress',
        'card_stripe_payment_intent_id' => 'getCardStripePaymentIntentId',
        'card_stripe_payment_intent_secret' => 'getCardStripePaymentIntentSecret',
        'addresses' => 'getAddresses',
        'events' => 'getEvents',
        'tokenised_cards' => 'getTokenisedCards',
        'transactions' => 'getTransactions',
        'tags' => 'getTags',
        'result' => 'getResult',
        'jwk' => 'getJwk',
        'priority_bank_id' => 'getPriorityBankId',
        'title' => 'getTitle',
        'partial_payment_steps' => 'getPartialPaymentSteps',
        'payrun_id' => 'getPayrunId',
        'shipping_address' => 'getShippingAddress',
        'notification_email_addresses' => 'getNotificationEmailAddresses',
        'payment_attempts' => 'getPaymentAttempts',
        'amount_received' => 'getAmountReceived',
        'amount_refunded' => 'getAmountRefunded',
        'amount_pending' => 'getAmountPending',
        'created_by_user' => 'getCreatedByUser',
        'merchant_token_description' => 'getMerchantTokenDescription',
        'formatted_amount' => 'getFormattedAmount',
        'lightning_invoice_expires_at' => 'getLightningInvoiceExpiresAt',
        'destination_account' => 'getDestinationAccount',
        'customer_name' => 'getCustomerName'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const CURRENCY_NONE = 'NONE';
    public const CURRENCY_GBP = 'GBP';
    public const CURRENCY_EUR = 'EUR';
    public const CURRENCY_BTC = 'BTC';
    public const PAYMENT_METHODS_NONE = 'None';
    public const PAYMENT_METHODS_CARD = 'card';
    public const PAYMENT_METHODS_PISP = 'pisp';
    public const PAYMENT_METHODS_LIGHTNING = 'lightning';
    public const PAYMENT_METHODS_CARDTOKEN = 'cardtoken';
    public const PAYMENT_METHODS_APPLE_PAY = 'applePay';
    public const PAYMENT_METHODS_GOOGLE_PAY = 'googlePay';
    public const PAYMENT_METHODS_DIRECT_DEBIT = 'directDebit';
    public const CARD_CREATE_TOKEN_MODE_NONE = 'None';
    public const CARD_CREATE_TOKEN_MODE_CONSENT_NOT_REQUIRED = 'ConsentNotRequired';
    public const CARD_CREATE_TOKEN_MODE_USER_CONSENT_REQUIRED = 'UserConsentRequired';
    public const PAYMENT_PROCESSOR_NONE = 'None';
    public const PAYMENT_PROCESSOR_CYBER_SOURCE = 'CyberSource';
    public const PAYMENT_PROCESSOR_CHECKOUT = 'Checkout';
    public const PAYMENT_PROCESSOR_STRIPE = 'Stripe';
    public const PAYMENT_PROCESSOR_MODULR = 'Modulr';
    public const PAYMENT_PROCESSOR_PLAID = 'Plaid';
    public const PAYMENT_PROCESSOR_YAPILY = 'Yapily';
    public const PAYMENT_PROCESSOR_NOFRIXION = 'Nofrixion';
    public const PAYMENT_PROCESSOR_BITCOIN = 'Bitcoin';
    public const PAYMENT_PROCESSOR_BITCOIN_TESTNET = 'BitcoinTestnet';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE = 'BankingCircle';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE_AGENCY = 'BankingCircleAgency';
    public const PAYMENT_PROCESSOR_SIMULATOR = 'Simulator';
    public const PAYMENT_PROCESSOR_LIGHTNING = 'Lightning';
    public const PAYMENT_PROCESSOR_LIGHTNING_TESTNET = 'LightningTestnet';
    public const PAYMENT_PROCESSOR_BANKING_CIRCLE_DIRECT_DEBIT = 'BankingCircleDirectDebit';
    public const PAYMENT_PROCESSOR_TRIBE = 'Tribe';
    public const STATUS_NONE = 'None';
    public const STATUS_FULLY_PAID = 'FullyPaid';
    public const STATUS_PARTIALLY_PAID = 'PartiallyPaid';
    public const STATUS_OVER_PAID = 'OverPaid';
    public const STATUS_VOIDED = 'Voided';
    public const STATUS_AUTHORIZED = 'Authorized';
    public const PARTIAL_PAYMENT_METHOD_NONE = 'None';
    public const PARTIAL_PAYMENT_METHOD_PARTIAL = 'Partial';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCurrencyAllowableValues()
    {
        return [
            self::CURRENCY_NONE,
            self::CURRENCY_GBP,
            self::CURRENCY_EUR,
            self::CURRENCY_BTC,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentMethodsAllowableValues()
    {
        return [
            self::PAYMENT_METHODS_NONE,
            self::PAYMENT_METHODS_CARD,
            self::PAYMENT_METHODS_PISP,
            self::PAYMENT_METHODS_LIGHTNING,
            self::PAYMENT_METHODS_CARDTOKEN,
            self::PAYMENT_METHODS_APPLE_PAY,
            self::PAYMENT_METHODS_GOOGLE_PAY,
            self::PAYMENT_METHODS_DIRECT_DEBIT,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCardCreateTokenModeAllowableValues()
    {
        return [
            self::CARD_CREATE_TOKEN_MODE_NONE,
            self::CARD_CREATE_TOKEN_MODE_CONSENT_NOT_REQUIRED,
            self::CARD_CREATE_TOKEN_MODE_USER_CONSENT_REQUIRED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentProcessorAllowableValues()
    {
        return [
            self::PAYMENT_PROCESSOR_NONE,
            self::PAYMENT_PROCESSOR_CYBER_SOURCE,
            self::PAYMENT_PROCESSOR_CHECKOUT,
            self::PAYMENT_PROCESSOR_STRIPE,
            self::PAYMENT_PROCESSOR_MODULR,
            self::PAYMENT_PROCESSOR_PLAID,
            self::PAYMENT_PROCESSOR_YAPILY,
            self::PAYMENT_PROCESSOR_NOFRIXION,
            self::PAYMENT_PROCESSOR_BITCOIN,
            self::PAYMENT_PROCESSOR_BITCOIN_TESTNET,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE_AGENCY,
            self::PAYMENT_PROCESSOR_SIMULATOR,
            self::PAYMENT_PROCESSOR_LIGHTNING,
            self::PAYMENT_PROCESSOR_LIGHTNING_TESTNET,
            self::PAYMENT_PROCESSOR_BANKING_CIRCLE_DIRECT_DEBIT,
            self::PAYMENT_PROCESSOR_TRIBE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_NONE,
            self::STATUS_FULLY_PAID,
            self::STATUS_PARTIALLY_PAID,
            self::STATUS_OVER_PAID,
            self::STATUS_VOIDED,
            self::STATUS_AUTHORIZED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPartialPaymentMethodAllowableValues()
    {
        return [
            self::PARTIAL_PAYMENT_METHOD_NONE,
            self::PARTIAL_PAYMENT_METHOD_PARTIAL,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('merchant_id', $data ?? [], null);
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('customer_id', $data ?? [], null);
        $this->setIfExists('order_id', $data ?? [], null);
        $this->setIfExists('payment_methods', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('pisp_account_id', $data ?? [], null);
        $this->setIfExists('base_origin_url', $data ?? [], null);
        $this->setIfExists('callback_url', $data ?? [], null);
        $this->setIfExists('failure_callback_url', $data ?? [], null);
        $this->setIfExists('success_web_hook_url', $data ?? [], null);
        $this->setIfExists('card_authorize_only', $data ?? [], null);
        $this->setIfExists('card_create_token', $data ?? [], null);
        $this->setIfExists('card_create_token_mode', $data ?? [], null);
        $this->setIfExists('ignore_address_verification', $data ?? [], null);
        $this->setIfExists('card_ignore_cvn', $data ?? [], null);
        $this->setIfExists('card_processor_merchant_id', $data ?? [], null);
        $this->setIfExists('payment_processor', $data ?? [], null);
        $this->setIfExists('lightning_invoice', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('hosted_pay_checkout_url', $data ?? [], null);
        $this->setIfExists('partial_payment_method', $data ?? [], null);
        $this->setIfExists('inserted', $data ?? [], null);
        $this->setIfExists('inserted_sortable', $data ?? [], null);
        $this->setIfExists('last_updated', $data ?? [], null);
        $this->setIfExists('use_hosted_payment_page', $data ?? [], null);
        $this->setIfExists('customer_email_address', $data ?? [], null);
        $this->setIfExists('card_stripe_payment_intent_id', $data ?? [], null);
        $this->setIfExists('card_stripe_payment_intent_secret', $data ?? [], null);
        $this->setIfExists('addresses', $data ?? [], null);
        $this->setIfExists('events', $data ?? [], null);
        $this->setIfExists('tokenised_cards', $data ?? [], null);
        $this->setIfExists('transactions', $data ?? [], null);
        $this->setIfExists('tags', $data ?? [], null);
        $this->setIfExists('result', $data ?? [], null);
        $this->setIfExists('jwk', $data ?? [], null);
        $this->setIfExists('priority_bank_id', $data ?? [], null);
        $this->setIfExists('title', $data ?? [], null);
        $this->setIfExists('partial_payment_steps', $data ?? [], null);
        $this->setIfExists('payrun_id', $data ?? [], null);
        $this->setIfExists('shipping_address', $data ?? [], null);
        $this->setIfExists('notification_email_addresses', $data ?? [], null);
        $this->setIfExists('payment_attempts', $data ?? [], null);
        $this->setIfExists('amount_received', $data ?? [], null);
        $this->setIfExists('amount_refunded', $data ?? [], null);
        $this->setIfExists('amount_pending', $data ?? [], null);
        $this->setIfExists('created_by_user', $data ?? [], null);
        $this->setIfExists('merchant_token_description', $data ?? [], null);
        $this->setIfExists('formatted_amount', $data ?? [], null);
        $this->setIfExists('lightning_invoice_expires_at', $data ?? [], null);
        $this->setIfExists('destination_account', $data ?? [], null);
        $this->setIfExists('customer_name', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getCurrencyAllowableValues();
        if (!is_null($this->container['currency']) && !in_array($this->container['currency'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'currency', must be one of '%s'",
                $this->container['currency'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCardCreateTokenModeAllowableValues();
        if (!is_null($this->container['card_create_token_mode']) && !in_array($this->container['card_create_token_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'card_create_token_mode', must be one of '%s'",
                $this->container['card_create_token_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPaymentProcessorAllowableValues();
        if (!is_null($this->container['payment_processor']) && !in_array($this->container['payment_processor'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_processor', must be one of '%s'",
                $this->container['payment_processor'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPartialPaymentMethodAllowableValues();
        if (!is_null($this->container['partial_payment_method']) && !in_array($this->container['partial_payment_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'partial_payment_method', must be one of '%s'",
                $this->container['partial_payment_method'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id id
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets merchant_id
     *
     * @return string|null
     */
    public function getMerchantId()
    {
        return $this->container['merchant_id'];
    }

    /**
     * Sets merchant_id
     *
     * @param string|null $merchant_id merchant_id
     *
     * @return self
     */
    public function setMerchantId($merchant_id)
    {
        if (is_null($merchant_id)) {
            throw new \InvalidArgumentException('non-nullable merchant_id cannot be null');
        }
        $this->container['merchant_id'] = $merchant_id;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return float|null
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param float|null $amount The amount of money to request.
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency The currency of the request.
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        $allowedValues = $this->getCurrencyAllowableValues();
        if (!in_array($currency, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'currency', must be one of '%s'",
                    $currency,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets customer_id
     *
     * @return string|null
     */
    public function getCustomerId()
    {
        return $this->container['customer_id'];
    }

    /**
     * Sets customer_id
     *
     * @param string|null $customer_id An optional customer identifier for the payment request.
     *
     * @return self
     */
    public function setCustomerId($customer_id)
    {
        if (is_null($customer_id)) {
            array_push($this->openAPINullablesSetToNull, 'customer_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('customer_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['customer_id'] = $customer_id;

        return $this;
    }

    /**
     * Gets order_id
     *
     * @return string|null
     */
    public function getOrderId()
    {
        return $this->container['order_id'];
    }

    /**
     * Sets order_id
     *
     * @param string|null $order_id An optional order ID for the payment request. If the request is for an invoice this  is the most appropriate field for the invoice ID.
     *
     * @return self
     */
    public function setOrderId($order_id)
    {
        if (is_null($order_id)) {
            array_push($this->openAPINullablesSetToNull, 'order_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('order_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['order_id'] = $order_id;

        return $this;
    }

    /**
     * Gets payment_methods
     *
     * @return string[]|null
     */
    public function getPaymentMethods()
    {
        return $this->container['payment_methods'];
    }

    /**
     * Sets payment_methods
     *
     * @param string[]|null $payment_methods The payment methods that the payment request supports.
     *
     * @return self
     */
    public function setPaymentMethods($payment_methods)
    {
        if (is_null($payment_methods)) {
            array_push($this->openAPINullablesSetToNull, 'payment_methods');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payment_methods', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getPaymentMethodsAllowableValues();
        if (!is_null($payment_methods) && array_diff($payment_methods, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'payment_methods', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_methods'] = $payment_methods;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description An optional description for the payment request. If set this field will appear  on the transaction record for some card processors.
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            array_push($this->openAPINullablesSetToNull, 'description');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('description', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets pisp_account_id
     *
     * @return string|null
     */
    public function getPispAccountId()
    {
        return $this->container['pisp_account_id'];
    }

    /**
     * Sets pisp_account_id
     *
     * @param string|null $pisp_account_id The payment account ID to use to receive payment initiation payments. This must match one of your  NoFrixion payment account IDs. This can be left blank to use your default payment account.
     *
     * @return self
     */
    public function setPispAccountId($pisp_account_id)
    {
        if (is_null($pisp_account_id)) {
            array_push($this->openAPINullablesSetToNull, 'pisp_account_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('pisp_account_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['pisp_account_id'] = $pisp_account_id;

        return $this;
    }

    /**
     * Gets base_origin_url
     *
     * @return string|null
     */
    public function getBaseOriginUrl()
    {
        return $this->container['base_origin_url'];
    }

    /**
     * Sets base_origin_url
     *
     * @param string|null $base_origin_url For card payments the origin of the payment page needs to be set in advance.  A public key context is generated to encrypt sensitive card details and is bound  to a single origin URL.
     *
     * @return self
     */
    public function setBaseOriginUrl($base_origin_url)
    {
        if (is_null($base_origin_url)) {
            array_push($this->openAPINullablesSetToNull, 'base_origin_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('base_origin_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['base_origin_url'] = $base_origin_url;

        return $this;
    }

    /**
     * Gets callback_url
     *
     * @return string|null
     */
    public function getCallbackUrl()
    {
        return $this->container['callback_url'];
    }

    /**
     * Sets callback_url
     *
     * @param string|null $callback_url Once a payment is processed, or a notification of an inbound payment is received,  a callback request will be made to this URL. Typically it will be the page on  a merchant's web site that displays the results of the payment attempt.
     *
     * @return self
     */
    public function setCallbackUrl($callback_url)
    {
        if (is_null($callback_url)) {
            array_push($this->openAPINullablesSetToNull, 'callback_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callback_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callback_url'] = $callback_url;

        return $this;
    }

    /**
     * Gets failure_callback_url
     *
     * @return string|null
     */
    public function getFailureCallbackUrl()
    {
        return $this->container['failure_callback_url'];
    }

    /**
     * Sets failure_callback_url
     *
     * @param string|null $failure_callback_url Optional callback URL for payment failures that can occur when the payer is   redirected away from the payment page. Typically the payer is only sent away  from the payment page for pay by bank attempts. If this URL is not set the   payer will be redirected back to the original URL the payment attempt was initiated  from.
     *
     * @return self
     */
    public function setFailureCallbackUrl($failure_callback_url)
    {
        if (is_null($failure_callback_url)) {
            array_push($this->openAPINullablesSetToNull, 'failure_callback_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('failure_callback_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['failure_callback_url'] = $failure_callback_url;

        return $this;
    }

    /**
     * Gets success_web_hook_url
     *
     * @return string|null
     */
    public function getSuccessWebHookUrl()
    {
        return $this->container['success_web_hook_url'];
    }

    /**
     * Sets success_web_hook_url
     *
     * @param string|null $success_web_hook_url If a payment event results in the payment request being classified as fully paid this  success webhook URL will be invoked. The URL will be invoked as a GET request, i.e.  there will be no request body. Two query parameters will be added to the URL. The   first one will be \"id\" and will hold the payment request ID. The second one will be  \"orderid\" and will hold the payment request OrderID, note the OrderID could be empty  if it was not set when the payment request was created.  The recommended approach when receiving a success web hook is to use the \"id\" parameter  to call the moneymoov get payment request endpoint to retrieve the full details of the  payment request and check the status. Web hooks can be easily spoofed and should not be  relied upon.
     *
     * @return self
     */
    public function setSuccessWebHookUrl($success_web_hook_url)
    {
        if (is_null($success_web_hook_url)) {
            array_push($this->openAPINullablesSetToNull, 'success_web_hook_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('success_web_hook_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['success_web_hook_url'] = $success_web_hook_url;

        return $this;
    }

    /**
     * Gets card_authorize_only
     *
     * @return bool|null
     */
    public function getCardAuthorizeOnly()
    {
        return $this->container['card_authorize_only'];
    }

    /**
     * Sets card_authorize_only
     *
     * @param bool|null $card_authorize_only For card payments the default behaviour is to authorise and capture the payment at the same  time. If a merchant needs to authorise and then capture at a later point this property needs  to be set to true.
     *
     * @return self
     */
    public function setCardAuthorizeOnly($card_authorize_only)
    {
        if (is_null($card_authorize_only)) {
            throw new \InvalidArgumentException('non-nullable card_authorize_only cannot be null');
        }
        $this->container['card_authorize_only'] = $card_authorize_only;

        return $this;
    }

    /**
     * Gets card_create_token
     *
     * @return bool|null
     */
    public function getCardCreateToken()
    {
        return $this->container['card_create_token'];
    }

    /**
     * Sets card_create_token
     *
     * @param bool|null $card_create_token For card payments a payment attempt can be used to create a reusable token for subsequent  payments. Setting this field to true will create a reusable customer token.
     *
     * @return self
     */
    public function setCardCreateToken($card_create_token)
    {
        if (is_null($card_create_token)) {
            throw new \InvalidArgumentException('non-nullable card_create_token cannot be null');
        }
        $this->container['card_create_token'] = $card_create_token;

        return $this;
    }

    /**
     * Gets card_create_token_mode
     *
     * @return string|null
     */
    public function getCardCreateTokenMode()
    {
        return $this->container['card_create_token_mode'];
    }

    /**
     * Sets card_create_token_mode
     *
     * @param string|null $card_create_token_mode This specifies whether user consent will be taken before tokenising card or not.  If this is set to 'UserConsentRequired' then, the user consent will potentially update   CardCreateToken flag on submit card payment.
     *
     * @return self
     */
    public function setCardCreateTokenMode($card_create_token_mode)
    {
        if (is_null($card_create_token_mode)) {
            throw new \InvalidArgumentException('non-nullable card_create_token_mode cannot be null');
        }
        $allowedValues = $this->getCardCreateTokenModeAllowableValues();
        if (!in_array($card_create_token_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'card_create_token_mode', must be one of '%s'",
                    $card_create_token_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['card_create_token_mode'] = $card_create_token_mode;

        return $this;
    }

    /**
     * Gets ignore_address_verification
     *
     * @return bool|null
     */
    public function getIgnoreAddressVerification()
    {
        return $this->container['ignore_address_verification'];
    }

    /**
     * Sets ignore_address_verification
     *
     * @param bool|null $ignore_address_verification If set to true the card payment gateway will be directed to proceed with a payment even if the  address verification checks fails.
     *
     * @return self
     */
    public function setIgnoreAddressVerification($ignore_address_verification)
    {
        if (is_null($ignore_address_verification)) {
            throw new \InvalidArgumentException('non-nullable ignore_address_verification cannot be null');
        }
        $this->container['ignore_address_verification'] = $ignore_address_verification;

        return $this;
    }

    /**
     * Gets card_ignore_cvn
     *
     * @return bool|null
     */
    public function getCardIgnoreCvn()
    {
        return $this->container['card_ignore_cvn'];
    }

    /**
     * Sets card_ignore_cvn
     *
     * @param bool|null $card_ignore_cvn If set to true the card payment gateway will be directed to proceed with a payment even if the  card verification number check fails.
     *
     * @return self
     */
    public function setCardIgnoreCvn($card_ignore_cvn)
    {
        if (is_null($card_ignore_cvn)) {
            throw new \InvalidArgumentException('non-nullable card_ignore_cvn cannot be null');
        }
        $this->container['card_ignore_cvn'] = $card_ignore_cvn;

        return $this;
    }

    /**
     * Gets card_processor_merchant_id
     *
     * @return string|null
     */
    public function getCardProcessorMerchantId()
    {
        return $this->container['card_processor_merchant_id'];
    }

    /**
     * Sets card_processor_merchant_id
     *
     * @param string|null $card_processor_merchant_id Optional field that if specified indicates the processor merchant ID that should be used  to process any card payments. Mainly useful where a merchant has multiple processor  merchant ID's. If left empty the default merchant card settings will be used.
     *
     * @return self
     */
    public function setCardProcessorMerchantId($card_processor_merchant_id)
    {
        if (is_null($card_processor_merchant_id)) {
            array_push($this->openAPINullablesSetToNull, 'card_processor_merchant_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('card_processor_merchant_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['card_processor_merchant_id'] = $card_processor_merchant_id;

        return $this;
    }

    /**
     * Gets payment_processor
     *
     * @return string|null
     */
    public function getPaymentProcessor()
    {
        return $this->container['payment_processor'];
    }

    /**
     * Sets payment_processor
     *
     * @param string|null $payment_processor If the card payment option is enabled this field indicates which card processor  the merchant is set up to use.
     *
     * @return self
     */
    public function setPaymentProcessor($payment_processor)
    {
        if (is_null($payment_processor)) {
            throw new \InvalidArgumentException('non-nullable payment_processor cannot be null');
        }
        $allowedValues = $this->getPaymentProcessorAllowableValues();
        if (!in_array($payment_processor, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_processor', must be one of '%s'",
                    $payment_processor,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_processor'] = $payment_processor;

        return $this;
    }

    /**
     * Gets lightning_invoice
     *
     * @return string|null
     */
    public function getLightningInvoice()
    {
        return $this->container['lightning_invoice'];
    }

    /**
     * Sets lightning_invoice
     *
     * @param string|null $lightning_invoice Bitcoin Lightning invoice for the payment request.
     *
     * @return self
     */
    public function setLightningInvoice($lightning_invoice)
    {
        if (is_null($lightning_invoice)) {
            array_push($this->openAPINullablesSetToNull, 'lightning_invoice');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('lightning_invoice', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['lightning_invoice'] = $lightning_invoice;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status The current status of the payment request. Will be set to FullyPaid when the full  amount has been received.
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets hosted_pay_checkout_url
     *
     * @return string|null
     */
    public function getHostedPayCheckoutUrl()
    {
        return $this->container['hosted_pay_checkout_url'];
    }

    /**
     * Sets hosted_pay_checkout_url
     *
     * @param string|null $hosted_pay_checkout_url This is a convenience link generated for payment requests whose merchants are using  hosted payment pages. The link will load the MoneyMoov hosted payment page. If the   merchant has not been set up for hosted payment or the payment can't be hosted then  this property will be empty.
     *
     * @return self
     */
    public function setHostedPayCheckoutUrl($hosted_pay_checkout_url)
    {
        if (is_null($hosted_pay_checkout_url)) {
            array_push($this->openAPINullablesSetToNull, 'hosted_pay_checkout_url');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('hosted_pay_checkout_url', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['hosted_pay_checkout_url'] = $hosted_pay_checkout_url;

        return $this;
    }

    /**
     * Gets partial_payment_method
     *
     * @return string|null
     */
    public function getPartialPaymentMethod()
    {
        return $this->container['partial_payment_method'];
    }

    /**
     * Sets partial_payment_method
     *
     * @param string|null $partial_payment_method The approach to use, or not, for accepting partial payments.
     *
     * @return self
     */
    public function setPartialPaymentMethod($partial_payment_method)
    {
        if (is_null($partial_payment_method)) {
            throw new \InvalidArgumentException('non-nullable partial_payment_method cannot be null');
        }
        $allowedValues = $this->getPartialPaymentMethodAllowableValues();
        if (!in_array($partial_payment_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'partial_payment_method', must be one of '%s'",
                    $partial_payment_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['partial_payment_method'] = $partial_payment_method;

        return $this;
    }

    /**
     * Gets inserted
     *
     * @return \DateTime|null
     */
    public function getInserted()
    {
        return $this->container['inserted'];
    }

    /**
     * Sets inserted
     *
     * @param \DateTime|null $inserted The timestamp the payment request was created at.
     *
     * @return self
     */
    public function setInserted($inserted)
    {
        if (is_null($inserted)) {
            throw new \InvalidArgumentException('non-nullable inserted cannot be null');
        }
        $this->container['inserted'] = $inserted;

        return $this;
    }

    /**
     * Gets inserted_sortable
     *
     * @return string|null
     */
    public function getInsertedSortable()
    {
        return $this->container['inserted_sortable'];
    }

    /**
     * Sets inserted_sortable
     *
     * @param string|null $inserted_sortable The Inserted timestamp output as a sortable string   https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#UniversalSortable   Format also supported natively by Javascript https://tc39.es/ecma262/#sec-date-time-string-format.
     *
     * @return self
     */
    public function setInsertedSortable($inserted_sortable)
    {
        if (is_null($inserted_sortable)) {
            array_push($this->openAPINullablesSetToNull, 'inserted_sortable');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('inserted_sortable', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['inserted_sortable'] = $inserted_sortable;

        return $this;
    }

    /**
     * Gets last_updated
     *
     * @return \DateTime|null
     */
    public function getLastUpdated()
    {
        return $this->container['last_updated'];
    }

    /**
     * Sets last_updated
     *
     * @param \DateTime|null $last_updated The timestamp the payment request was last updated at.
     *
     * @return self
     */
    public function setLastUpdated($last_updated)
    {
        if (is_null($last_updated)) {
            throw new \InvalidArgumentException('non-nullable last_updated cannot be null');
        }
        $this->container['last_updated'] = $last_updated;

        return $this;
    }

    /**
     * Gets use_hosted_payment_page
     *
     * @return bool|null
     */
    public function getUseHostedPaymentPage()
    {
        return $this->container['use_hosted_payment_page'];
    }

    /**
     * Sets use_hosted_payment_page
     *
     * @param bool|null $use_hosted_payment_page If set to true, and the merchant is configured for hosted payment pages, the base and callback URLs  will be set to use the hosted payment page.
     *
     * @return self
     */
    public function setUseHostedPaymentPage($use_hosted_payment_page)
    {
        if (is_null($use_hosted_payment_page)) {
            throw new \InvalidArgumentException('non-nullable use_hosted_payment_page cannot be null');
        }
        $this->container['use_hosted_payment_page'] = $use_hosted_payment_page;

        return $this;
    }

    /**
     * Gets customer_email_address
     *
     * @return string|null
     */
    public function getCustomerEmailAddress()
    {
        return $this->container['customer_email_address'];
    }

    /**
     * Sets customer_email_address
     *
     * @param string|null $customer_email_address Optional email address for the customer. If the tokenise card option is set then the customer email address  is mandatory.
     *
     * @return self
     */
    public function setCustomerEmailAddress($customer_email_address)
    {
        if (is_null($customer_email_address)) {
            array_push($this->openAPINullablesSetToNull, 'customer_email_address');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('customer_email_address', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['customer_email_address'] = $customer_email_address;

        return $this;
    }

    /**
     * Gets card_stripe_payment_intent_id
     *
     * @return string|null
     */
    public function getCardStripePaymentIntentId()
    {
        return $this->container['card_stripe_payment_intent_id'];
    }

    /**
     * Sets card_stripe_payment_intent_id
     *
     * @param string|null $card_stripe_payment_intent_id If Stripe is being used as the card payment processor this property is used to hold the Stripe payment intent ID.
     *
     * @return self
     */
    public function setCardStripePaymentIntentId($card_stripe_payment_intent_id)
    {
        if (is_null($card_stripe_payment_intent_id)) {
            array_push($this->openAPINullablesSetToNull, 'card_stripe_payment_intent_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('card_stripe_payment_intent_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['card_stripe_payment_intent_id'] = $card_stripe_payment_intent_id;

        return $this;
    }

    /**
     * Gets card_stripe_payment_intent_secret
     *
     * @return string|null
     */
    public function getCardStripePaymentIntentSecret()
    {
        return $this->container['card_stripe_payment_intent_secret'];
    }

    /**
     * Sets card_stripe_payment_intent_secret
     *
     * @param string|null $card_stripe_payment_intent_secret If Stripe is being used as the card payment processor this property is used to hold the Stripe payment intent client secret.
     *
     * @return self
     */
    public function setCardStripePaymentIntentSecret($card_stripe_payment_intent_secret)
    {
        if (is_null($card_stripe_payment_intent_secret)) {
            array_push($this->openAPINullablesSetToNull, 'card_stripe_payment_intent_secret');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('card_stripe_payment_intent_secret', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['card_stripe_payment_intent_secret'] = $card_stripe_payment_intent_secret;

        return $this;
    }

    /**
     * Gets addresses
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestAddress[]|null
     */
    public function getAddresses()
    {
        return $this->container['addresses'];
    }

    /**
     * Sets addresses
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestAddress[]|null $addresses addresses
     *
     * @return self
     */
    public function setAddresses($addresses)
    {
        if (is_null($addresses)) {
            array_push($this->openAPINullablesSetToNull, 'addresses');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('addresses', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['addresses'] = $addresses;

        return $this;
    }

    /**
     * Gets events
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestEvent[]|null
     */
    public function getEvents()
    {
        return $this->container['events'];
    }

    /**
     * Sets events
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestEvent[]|null $events events
     *
     * @return self
     */
    public function setEvents($events)
    {
        if (is_null($events)) {
            array_push($this->openAPINullablesSetToNull, 'events');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('events', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['events'] = $events;

        return $this;
    }

    /**
     * Gets tokenised_cards
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsCardCustomerToken[]|null
     */
    public function getTokenisedCards()
    {
        return $this->container['tokenised_cards'];
    }

    /**
     * Sets tokenised_cards
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsCardCustomerToken[]|null $tokenised_cards tokenised_cards
     *
     * @return self
     */
    public function setTokenisedCards($tokenised_cards)
    {
        if (is_null($tokenised_cards)) {
            array_push($this->openAPINullablesSetToNull, 'tokenised_cards');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tokenised_cards', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tokenised_cards'] = $tokenised_cards;

        return $this;
    }

    /**
     * Gets transactions
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTransaction[]|null
     */
    public function getTransactions()
    {
        return $this->container['transactions'];
    }

    /**
     * Sets transactions
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTransaction[]|null $transactions transactions
     *
     * @return self
     */
    public function setTransactions($transactions)
    {
        if (is_null($transactions)) {
            array_push($this->openAPINullablesSetToNull, 'transactions');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('transactions', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['transactions'] = $transactions;

        return $this;
    }

    /**
     * Gets tags
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTag[]|null
     */
    public function getTags()
    {
        return $this->container['tags'];
    }

    /**
     * Sets tags
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsTag[]|null $tags An optional list of descriptive tags attached to the payment request.
     *
     * @return self
     */
    public function setTags($tags)
    {
        if (is_null($tags)) {
            array_push($this->openAPINullablesSetToNull, 'tags');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tags', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['tags'] = $tags;

        return $this;
    }

    /**
     * Gets result
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestResult|null
     */
    public function getResult()
    {
        return $this->container['result'];
    }

    /**
     * Sets result
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestResult|null $result result
     *
     * @return self
     */
    public function setResult($result)
    {
        if (is_null($result)) {
            throw new \InvalidArgumentException('non-nullable result cannot be null');
        }
        $this->container['result'] = $result;

        return $this;
    }

    /**
     * Gets jwk
     *
     * @return string|null
     */
    public function getJwk()
    {
        return $this->container['jwk'];
    }

    /**
     * Sets jwk
     *
     * @param string|null $jwk The jwk containing the public key used to verify the signature of the payment request.
     *
     * @return self
     */
    public function setJwk($jwk)
    {
        if (is_null($jwk)) {
            array_push($this->openAPINullablesSetToNull, 'jwk');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('jwk', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['jwk'] = $jwk;

        return $this;
    }

    /**
     * Gets priority_bank_id
     *
     * @return string|null
     */
    public function getPriorityBankId()
    {
        return $this->container['priority_bank_id'];
    }

    /**
     * Sets priority_bank_id
     *
     * @param string|null $priority_bank_id The ID of the bank that is set as the priority bank for display on pay element.
     *
     * @return self
     */
    public function setPriorityBankId($priority_bank_id)
    {
        if (is_null($priority_bank_id)) {
            array_push($this->openAPINullablesSetToNull, 'priority_bank_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('priority_bank_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['priority_bank_id'] = $priority_bank_id;

        return $this;
    }

    /**
     * Gets title
     *
     * @return string|null
     */
    public function getTitle()
    {
        return $this->container['title'];
    }

    /**
     * Sets title
     *
     * @param string|null $title A generic field to contain any additional data that the merchant wishes to store against the payment request.  E.g. product or service information.
     *
     * @return self
     */
    public function setTitle($title)
    {
        if (is_null($title)) {
            array_push($this->openAPINullablesSetToNull, 'title');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('title', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['title'] = $title;

        return $this;
    }

    /**
     * Gets partial_payment_steps
     *
     * @return string|null
     */
    public function getPartialPaymentSteps()
    {
        return $this->container['partial_payment_steps'];
    }

    /**
     * Sets partial_payment_steps
     *
     * @param string|null $partial_payment_steps An optional comma separated list of partial payment amounts. The amounts represent guidance, or suggestions, as to  how the payer will be requested to make partial payments.
     *
     * @return self
     */
    public function setPartialPaymentSteps($partial_payment_steps)
    {
        if (is_null($partial_payment_steps)) {
            array_push($this->openAPINullablesSetToNull, 'partial_payment_steps');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('partial_payment_steps', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['partial_payment_steps'] = $partial_payment_steps;

        return $this;
    }

    /**
     * Gets payrun_id
     *
     * @return string|null
     */
    public function getPayrunId()
    {
        return $this->container['payrun_id'];
    }

    /**
     * Sets payrun_id
     *
     * @param string|null $payrun_id The ID of a payrun that needs an account top up.   Payment request can be used to top up payrun accounts.
     *
     * @return self
     */
    public function setPayrunId($payrun_id)
    {
        if (is_null($payrun_id)) {
            array_push($this->openAPINullablesSetToNull, 'payrun_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payrun_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payrun_id'] = $payrun_id;

        return $this;
    }

    /**
     * Gets shipping_address
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestAddress|null
     */
    public function getShippingAddress()
    {
        return $this->container['shipping_address'];
    }

    /**
     * Sets shipping_address
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestAddress|null $shipping_address shipping_address
     *
     * @return self
     */
    public function setShippingAddress($shipping_address)
    {
        if (is_null($shipping_address)) {
            throw new \InvalidArgumentException('non-nullable shipping_address cannot be null');
        }
        $this->container['shipping_address'] = $shipping_address;

        return $this;
    }

    /**
     * Gets notification_email_addresses
     *
     * @return string|null
     */
    public function getNotificationEmailAddresses()
    {
        return $this->container['notification_email_addresses'];
    }

    /**
     * Sets notification_email_addresses
     *
     * @param string|null $notification_email_addresses notification_email_addresses
     *
     * @return self
     */
    public function setNotificationEmailAddresses($notification_email_addresses)
    {
        if (is_null($notification_email_addresses)) {
            array_push($this->openAPINullablesSetToNull, 'notification_email_addresses');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('notification_email_addresses', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['notification_email_addresses'] = $notification_email_addresses;

        return $this;
    }

    /**
     * Gets payment_attempts
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestPaymentAttempt[]|null
     */
    public function getPaymentAttempts()
    {
        return $this->container['payment_attempts'];
    }

    /**
     * Sets payment_attempts
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentRequestPaymentAttempt[]|null $payment_attempts The payment attempts made against this payment request.
     *
     * @return self
     */
    public function setPaymentAttempts($payment_attempts)
    {
        if (is_null($payment_attempts)) {
            array_push($this->openAPINullablesSetToNull, 'payment_attempts');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payment_attempts', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['payment_attempts'] = $payment_attempts;

        return $this;
    }

    /**
     * Gets amount_received
     *
     * @return float|null
     */
    public function getAmountReceived()
    {
        return $this->container['amount_received'];
    }

    /**
     * Sets amount_received
     *
     * @param float|null $amount_received Total amount received for this payment request.
     *
     * @return self
     */
    public function setAmountReceived($amount_received)
    {
        if (is_null($amount_received)) {
            throw new \InvalidArgumentException('non-nullable amount_received cannot be null');
        }
        $this->container['amount_received'] = $amount_received;

        return $this;
    }

    /**
     * Gets amount_refunded
     *
     * @return float|null
     */
    public function getAmountRefunded()
    {
        return $this->container['amount_refunded'];
    }

    /**
     * Sets amount_refunded
     *
     * @param float|null $amount_refunded Total amount refunded for this payment request.
     *
     * @return self
     */
    public function setAmountRefunded($amount_refunded)
    {
        if (is_null($amount_refunded)) {
            throw new \InvalidArgumentException('non-nullable amount_refunded cannot be null');
        }
        $this->container['amount_refunded'] = $amount_refunded;

        return $this;
    }

    /**
     * Gets amount_pending
     *
     * @return float|null
     */
    public function getAmountPending()
    {
        return $this->container['amount_pending'];
    }

    /**
     * Sets amount_pending
     *
     * @param float|null $amount_pending Total amount that has been authorised but not settled for this payment request.
     *
     * @return self
     */
    public function setAmountPending($amount_pending)
    {
        if (is_null($amount_pending)) {
            throw new \InvalidArgumentException('non-nullable amount_pending cannot be null');
        }
        $this->container['amount_pending'] = $amount_pending;

        return $this;
    }

    /**
     * Gets created_by_user
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsUser|null
     */
    public function getCreatedByUser()
    {
        return $this->container['created_by_user'];
    }

    /**
     * Sets created_by_user
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsUser|null $created_by_user created_by_user
     *
     * @return self
     */
    public function setCreatedByUser($created_by_user)
    {
        if (is_null($created_by_user)) {
            throw new \InvalidArgumentException('non-nullable created_by_user cannot be null');
        }
        $this->container['created_by_user'] = $created_by_user;

        return $this;
    }

    /**
     * Gets merchant_token_description
     *
     * @return string|null
     */
    public function getMerchantTokenDescription()
    {
        return $this->container['merchant_token_description'];
    }

    /**
     * Sets merchant_token_description
     *
     * @param string|null $merchant_token_description Description of the merchant token in case the Payment request was created using a merchant token.
     *
     * @return self
     */
    public function setMerchantTokenDescription($merchant_token_description)
    {
        if (is_null($merchant_token_description)) {
            array_push($this->openAPINullablesSetToNull, 'merchant_token_description');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('merchant_token_description', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['merchant_token_description'] = $merchant_token_description;

        return $this;
    }

    /**
     * Gets formatted_amount
     *
     * @return string|null
     */
    public function getFormattedAmount()
    {
        return $this->container['formatted_amount'];
    }

    /**
     * Sets formatted_amount
     *
     * @param string|null $formatted_amount formatted_amount
     *
     * @return self
     */
    public function setFormattedAmount($formatted_amount)
    {
        if (is_null($formatted_amount)) {
            array_push($this->openAPINullablesSetToNull, 'formatted_amount');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('formatted_amount', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['formatted_amount'] = $formatted_amount;

        return $this;
    }

    /**
     * Gets lightning_invoice_expires_at
     *
     * @return \DateTime|null
     */
    public function getLightningInvoiceExpiresAt()
    {
        return $this->container['lightning_invoice_expires_at'];
    }

    /**
     * Sets lightning_invoice_expires_at
     *
     * @param \DateTime|null $lightning_invoice_expires_at Date and time of expiration of the lightning invoice.
     *
     * @return self
     */
    public function setLightningInvoiceExpiresAt($lightning_invoice_expires_at)
    {
        if (is_null($lightning_invoice_expires_at)) {
            array_push($this->openAPINullablesSetToNull, 'lightning_invoice_expires_at');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('lightning_invoice_expires_at', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['lightning_invoice_expires_at'] = $lightning_invoice_expires_at;

        return $this;
    }

    /**
     * Gets destination_account
     *
     * @return \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentAccount|null
     */
    public function getDestinationAccount()
    {
        return $this->container['destination_account'];
    }

    /**
     * Sets destination_account
     *
     * @param \Nofrixion\Client\Model\NoFrixionMoneyMoovModelsPaymentAccount|null $destination_account destination_account
     *
     * @return self
     */
    public function setDestinationAccount($destination_account)
    {
        if (is_null($destination_account)) {
            throw new \InvalidArgumentException('non-nullable destination_account cannot be null');
        }
        $this->container['destination_account'] = $destination_account;

        return $this;
    }

    /**
     * Gets customer_name
     *
     * @return string|null
     */
    public function getCustomerName()
    {
        return $this->container['customer_name'];
    }

    /**
     * Sets customer_name
     *
     * @param string|null $customer_name customer_name
     *
     * @return self
     */
    public function setCustomerName($customer_name)
    {
        if (is_null($customer_name)) {
            array_push($this->openAPINullablesSetToNull, 'customer_name');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('customer_name', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['customer_name'] = $customer_name;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


